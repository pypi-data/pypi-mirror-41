import re

import numpy as np
import sympy
from sympy import collect


def pow2mul(instr):
    """Expand power to multiplications

    Substitutes x**5 or pow(x, 5) by x*x*x*x*x

    Parameters
    ----------
    instr : str
        The input string

    Returns
    -------
    outstr : str
        The output string

    """
    old_new = []
    outstr = instr
    search = r'\w+\*\*\s*\d+|\([^\(\)]+\)\*\*\d+'
    for p in re.findall(search, instr):
        var, exp = p.replace(' ', '').split('**')
        new = '(' + '*'.join([var]*int(exp)) + ')'
        old_new.append([p, new])
    # putting longer patterns first to avoid wrong
    # substitutions
    old_new = sorted(old_new, key=lambda x: len(x[0]))[::-1]
    for old, new in old_new:
        outstr = outstr.replace(old, new)

    old_new = []
    for p in re.findall(r'pow\(\s*[^,]+\s*,\s*[^,\)]+\s*\)', instr):
        var, exp = p.split('pow')[1].split(',')
        var = var.strip()[1:] # removing left parentheses
        exp = exp.strip()[:-1] # removing right parentheses
        new = '(' + '*'.join(['(' + var.replace(' ', '') + ')']*int(exp)) + ')'
        old_new.append([p, new])
    for old, new in old_new:
        outstr = outstr.replace(old, new)

    return outstr


def mprint_as_sparse(m, mname, sufix=None, subs=None, header=None,
        print_file=True, collect_for=None, pow_by_mul=True,
        is_symmetric=False, dofpernode=None):
    """Print sympy.Matrix in a proper format for sparse implementations

    Parameters
    ----------
    m : sympy.Matrix object
        The matrix to be printed
    mname : str
        Name given to the matrix
    sufix : str
        A sufix that will appear in the file name
    subs : dict or None, optional
        A dictionary used to perform substitutions using SymPy
    header : str or None, optional
        A header added to the printed lines
    print_file : bool, optional
        If a .txt file should be created with the printed lines
    collect_for : list or None, optional
        Symbols for each the expressions should be collected for
    pow_by_mul : bool, optional
        Replace `a**3` by `a*a*a`, which ultimately generates a faster code,
        preventing `pow()` calls in a C code generated by Cython
    is_symmetric : bool or None, optional
        Tells whether the output matrix is symmetric. If True, prints only
        terms in the upper triangle.
    dofpernode : int or None, optional
        If given it is used to adjust the printed matrices in order to
        facilitate the implementation

    """
    if sufix is None:
        namesufix = '{0}'.format(mname)
    else:
        namesufix = '{0}_{1}'.format(mname, sufix)
    filename = 'print_{0}.txt'.format(namesufix)
    ls = []
    if header:
        ls.append(header)
    ls.append('# {0}'.format(namesufix))

    num = 0
    for (i, j), v in np.ndenumerate(m):
        if dofpernode:
            nindi = (i // dofpernode) + 1
            nindj = (j // dofpernode) + 1
            i = i % dofpernode
            j = j % dofpernode
        if v:
            if is_symmetric and i > j:
                continue

            if subs:
                v = v.subs(subs)
            num += 1
            ls.append('c += 1')

            if dofpernode:
                ls.append('{mname}r[c] = i{nindi}*dof+{i}'.format(mname=mname, i=i, nindi=nindi))
                ls.append('{mname}c[c] = i{nindj}*dof+{j}'.format(mname=mname, j=j, nindj=nindj))
            else:
                ls.append('{mname}r[c] = row+{i}'.format(mname=mname, i=i))
                ls.append('{mname}c[c] = col+{j}'.format(mname=mname, j=j))

            if collect_for is not None:
                v = collect(v, collect_for, evaluate=False)
                ls.append('{mname}v[c] +='.format(mname=mname))
                for k, expr in v.items():
                    ls.append('#   collected for {k}'.format(k=k))
                    ls.append('    {expr}'.format(expr=k*expr))
            else:
                if pow_by_mul:
                    v = pow2mul(str(v))
                ls.append('{mname}v[c] += {v}'.format(mname=mname, v=v))

    ls.insert(1, '# {0}_num={1}'.format(namesufix, num))

    string = '\n'.join(ls)

    if subs:
        items = sorted(subs.items(), key= lambda x: str(x[1]))
        items = [(k, v) for k, v in items if str(v) in string]
        if items:
            ls_header = []
            ls_header.append('subs\n')
            for k, v in items:
                ls_header.append('{0} = {1}'.format(v, k))
            ls_header.append('\n')

            string = '\n'.join(ls_header + ls)

    if print_file:
        with open(filename, 'w') as f:
            f.write(string)
    return string


def mprint_as_dense(m, mname, subs=None, header=None, print_file=True,
        collect_for=None, pow_by_mul=True, dofpernode=None):
    """Print sympy.Matrix in a proper format for dense matrix definitions

    Parameters
    ----------
    m : sympy.Matrix object
        The matrix to be printed
    mname : str
        Name given to the matrix
    subs : dict or None, optional
        A dictionary used to perform substitutions using SymPy
    header : str or None, optional
        A header added to the printed lines
    print_file : bool, optional
        If a .txt file should be created with the printed lines
    collect_for : list or None, optional
        Symbols for each the expressions should be collected for
    pow_by_mul : bool, optional
        Replace `a**3` by `a*a*a`, which ultimately generates a faster code,
        preventing `pow()` calls in a C code generated by Cython
    dofpernode : int or None, optional
        If given it is used to adjust the printed matrices in order to
        facilitate the implementation

    """
    namesufix = '{0}'.format(mname)
    filename = 'print_{0}.txt'.format(namesufix)
    ls = []
    if header:
        ls.append(header)
    ls.append('# {0}'.format(namesufix))

    num = len([None for (i, j), v in np.ndenumerate(m) if v])

    ls.append('# {0}_num={1}'.format(namesufix, num))

    for (i, j), v in np.ndenumerate(m):
        if dofpernode:
            nindi = (i // dofpernode) + 1
            nindj = (j // dofpernode) + 1
            i = i % dofpernode
            j = j % dofpernode
        if v:
            if subs:
                v = v.subs(subs)
            if collect_for is not None:
                v = collect(v, collect_for, evaluate=False)
                if dofpernode:
                    ls.append('{mname}[i{nindi}*dof+{i}, i{nindj}*dof+{j}] +='.format(
                        mname=mname, i=i, j=j, nindi=nindi, nindj=nindj))
                else:
                    ls.append('{mname}[{i}, {j}] +='.format(mname=mname, i=i, j=j))
                for k, expr in v.items():
                    ls.append('#   collected for {k}'.format(k=k))
                    ls.append('    {expr}'.format(expr=k*expr))
            else:
                if pow_by_mul:
                    v = pow2mul(str(v))
                if dofpernode:
                    ls.append('{mname}[i{nindi}*dof+{i}, i{nindj}*dof+{j}] += {v}'.format(
                        mname=mname, i=i, j=j, v=v, nindi=nindi, nindj=nindj))
                else:
                    ls.append('{mname}[{i}, {j}] += {v}'.format(mname=mname,
                        i=i, j=j, v=v))

    string = '\n'.join(ls)

    if subs:
        items = sorted(subs.items(), key= lambda x: str(x[1]))
        items = [(k, v) for k, v in items if str(v) in string]
        if items:
            ls_header = []
            ls_header.append('# subs')
            for k, v in items:
                ls_header.append('# {0} = {1}'.format(v, k))
            string = '\n'.join(ls_header + ls)

    if print_file:
        with open(filename, 'w') as f:
            f.write(string)
    return string


def mprint_as_array(m, mname, sufix=None, use_cse=False, header=None,
        print_file=True, collect_for=None, pow_by_mul=True, order='C',
        op='+='):
    """Print sympy.Matrix in a proper format for sparse implementations

    .. note:: This will probably be deprecated

    Parameters
    ----------
    m : sympy.Matrix object
        The matrix to be printed
    mname : str
        Name given to the matrix
    sufix : str
        A sufix that will appear in the file name
    header : str or None, optional
        A header added to the printed lines
    print_file : bool, optional
        If a .txt file should be created with the printed lines
    collect_for : list or None, optional
        Symbols for each the expressions should be collected for
    pow_by_mul : bool, optional
        Replace `a**3` by `a*a*a`, which ultimately generates a faster code,
        preventing `pow()` calls in a C code generated by Cython
    order : str ('C' or 'F')
        Tell how indices should grow optimizing according to the memory
        architecture: C - row contiguous; or Fortran - column contiguous
    op : str, optional
        If in the implementation one wishes to sum in place or do something
        else

    """
    ls = []
    if use_cse:
        subs, m_list = sympy.cse(m)
        for i, v in enumerate(m_list):
            m[i] = v
    if sufix is None:
        namesufix = '{0}'.format(mname)
    else:
        namesufix = '{0}_{1}'.format(mname, sufix)
    filename = 'print_{0}.txt'.format(namesufix)
    if header:
        ls.append(header)
    if use_cse:
        ls.append('# cdefs')
        num = 9
        for i, sub in enumerate(subs[::num]):
            ls.append('cdef double ' + ', '.join(
                        map(str, [j[0] for j in subs[num*i:num*(i+1)]])))
        ls.append('# subs')
        for sub in subs:
            ls.append('{0} = {1}'.format(*sub))
    ls.append('# {0}'.format(namesufix))
    num = len([i for i in list(m) if i])
    ls.append('# {0}_num={1}'.format(namesufix, num))
    if order == 'C':
        miter = enumerate(np.ravel(m))
    elif order == 'F':
        miter = enumerate(np.ravel(m.T))
    miter = list(miter)
    for i, v in miter:
        if v:
            if collect_for is not None:
                v = collect(v, collect_for, evaluate=False)
                ls.append('{0}[pos+{1}] +='.format(mname, i))
                for k, expr in v.items():
                    ls.append('#   collected for {k}'.format(k=k))
                    ls.append('    {expr}'.format(expr=k*expr))
            else:
                if pow_by_mul:
                    v = str(v)
                    for p in re.findall(r'\w+\*\*\d+', v):
                        var, exp = p.split('**')
                        v = v.replace(p, '(' + '*'.join([var]*int(exp)) + ')')
                ls.append('{0}[pos+{1}] {2} {3}'.format(mname, i, op, v))
    string = '\n'.join(ls)
    if print_file:
        with open(filename, 'w') as f:
            f.write(string)
    return string

