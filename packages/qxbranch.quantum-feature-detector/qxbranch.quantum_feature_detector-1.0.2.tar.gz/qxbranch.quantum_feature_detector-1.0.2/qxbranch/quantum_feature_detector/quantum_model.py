# -------------------------------------------------------------------------------------------------
# Quantum Feature Detector
# Copyright 2018 QxBranch, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# To learn more about QxBranch, see <https://www.qxbranch.com>.
# -------------------------------------------------------------------------------------------------

from typing import Any, Optional, Sequence
import sklearn
from sklearn.linear_model import LogisticRegression
import numpy as np

from qxbranch.quantum_feature_detector import logging_service, QuantumFeatureDetector, EncoderBase, DecoderBase


class QuantumModel:
    """
    Class that builds and trains the overall quantum feature detector machine learning model.

    .. note:
        For full working examples, check out the demonstration notebooks included with QxBranch's Quantum Feature
        Detector library in the `demos` folder.

    :Example:
        Build up a simple machine learning stack using the QxBranch Quantum Feature Detector library.


        >>> qubits = 5
        >>> gate_count = 8
        >>> data_size = 4
        >>> qfd_count = 15
        >>> circuit_generator = CircuitGeneratorPyquil(qubit_count=qubits,
        ...                                            gate_count=gate_count,
        ...                                            number_of_runs=10,
        ...                                            random_instance=Random(1))
        >>> qfds = [QuantumFeatureDetector(circuit=circuit) for circuit in
        ...         circuit_generator.generate_multiple(qfd_count)]
        >>> quantum_model = QuantumModel(quantum_feature_detectors=qfds,
        ...                              encoder=EncoderPyquilQuantumKitchenSinks(
        ...                                 qubit_count=qubits, data_size=data_size),
        ...                              decoder=DecoderPyquilMostCommon())
        >>> quantum_model.train(training_data=training_data, data_labels=data_labels)
        >>> quantum_image_features = quantum_model.predict(test_data=test_data)

        To use the :py:class:`QuantumModel` as part of a custom machine learning stack, decoupled from the internalized
        sklearn model, try the following usage pattern:

        >>> quantum_model = QuantumModel(quantum_feature_detectors=qfds,
        ...                              encoder=EncoderPyquilQuantumKitchenSinks(
        ...                                 qubit_count=qubits, data_size=data_size),
        ...                              decoder=DecoderPyquilMostCommon())
        >>> transformed_training_data = quantum_model.quantum_transform_data(training_data)
        >>> transformed_test_data = quantum_model.quantum_transform_data(test_data)

    :param quantum_feature_detectors: The QFD's used to apply quantum transformations to the data used in the machine
        learning model.
    :param encoder: The encoder used to code the input data into the quantum circuits.
    :param decoder: The decoder used to interpret the results of running the quantum circuits.
    :param classical_model: Optional, the classical scikit-learn model to train on the quantum- transformed data
        generated by the QFD's. Defaults to a :py:class:`sklearn.linear_model.LogisticRegression` model.
    """

    def __init__(self, quantum_feature_detectors: Sequence[QuantumFeatureDetector], encoder: EncoderBase,
                 decoder: DecoderBase,
                 classical_model: sklearn.linear_model = LogisticRegression(solver = 'lbfgs')) -> None:
        self._logger = logging_service.get_logger(self.__class__.__name__)

        if isinstance(quantum_feature_detectors, tuple):
            self._quantum_feature_detectors = quantum_feature_detectors
        else:
            self._quantum_feature_detectors = tuple(quantum_feature_detectors)

        if len(self._quantum_feature_detectors) < 1:
            raise ValueError("No QFD's given to the model!")

        if self._quantum_feature_detectors[0].circuit.qubit_count != encoder.qubit_count:
            raise ValueError(
                "QFDs and Encoder have incompatible qubit counts ({} & {}, respectively). Please ensure they use the"
                "same number of qubits.".format(self._quantum_feature_detectors[0].circuit.qubit_count,
                                                encoder.qubit_count))

        if isinstance(encoder, EncoderBase):
            self._encoder = encoder
        else:
            raise TypeError("Encoder {} is not a valid Encoder".format(encoder))

        if isinstance(decoder, DecoderBase):
            self._decoder = decoder
        else:
            raise TypeError("Decoder {} is not a valid Decoder".format(decoder))

        self._model = classical_model

    def train(self, training_data: Sequence[Sequence[Any]], data_labels: Sequence[Any]) -> None:
        """
        Train the model on labeled training data.

        :param training_data: Array containing the training data. Expected to be at most 2D.
        :param data_labels: Array of labels for each item in the training dataset.
        """
        self._logger.debug("Training on classical data with shape: {}".format(np.array(training_data).shape))
        transformed_training_data = self.quantum_transform_data(training_data)
        self._logger.debug("Training classical model on quantum transformed data with shape: {}".format(
            np.array(transformed_training_data).shape))
        self._model.fit(transformed_training_data, data_labels)
        self._logger.debug("Training success!")

    def predict(self, test_data: Sequence[Sequence[Any]]) -> Any:
        """
        Use the quantum model to predict the label of unlabeled test data.

        :param test_data: Array containing the test data. Expected to be at most 2D.
        :return: The most likely label for `test_data` as predicted by the model.
        """
        self._logger.debug("Testing classical data with shape: {}".format(np.array(test_data).shape))
        transformed_test_data = self.quantum_transform_data(test_data)
        self._logger.debug("Transformed test data has shape: {}".format(np.array(transformed_test_data).shape))
        return self._model.predict(transformed_test_data)

    def quantum_transform_data(self, input_data: Sequence[Sequence[Any]]) -> Sequence[Optional[Sequence[Any]]]:
        """
        Transforms the provided data by applying the quantum feature detectors in this model. Supports customizable use
        of the :py:class:`QuantumModel` in machine learning stacks.

        :param input_data: Array containing the data. Expected to be at most 2D.
        :return: Vector of quantum-transformed data.
        """
        return [self._apply_qfds_to_data(data) for data in input_data]

    def _apply_qfds_to_data(self, data: Sequence[Any]) -> Sequence[Optional[Sequence[Any]]]:
        """
        Applies the quantum feature detectors in this model to the provided data.

        :param data: The vector of data to run through the quantum feature detectors.
        :return: Vector of quantum-transformed data.
        """
        self._logger.debug("Applying {} QFD's to data of shape {}.".format(len(self._quantum_feature_detectors),
                                                                           np.array(data).shape))
        transformed_data = []  # type: Sequence[Optional[Sequence[Any]]]
        for qfd in self._quantum_feature_detectors:
            qfd_output = qfd.apply_to_data(data, self._encoder, self._decoder)
            if isinstance(qfd_output, list):
                transformed_data += qfd_output
            else:
                transformed_data += [qfd_output]
        self._logger.debug("Transformed data shape: {}".format(np.array(transformed_data).shape))
        return transformed_data
