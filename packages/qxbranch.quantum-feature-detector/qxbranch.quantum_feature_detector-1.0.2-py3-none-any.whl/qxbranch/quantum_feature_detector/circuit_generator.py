# -------------------------------------------------------------------------------------------------
# Quantum Feature Detector
# Copyright 2018 QxBranch, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# To learn more about QxBranch, see <https://www.qxbranch.com>.
# -------------------------------------------------------------------------------------------------

from abc import abstractmethod

import networkx as nx
import numpy as np
import random

# flake8 doesn't check the usage of List in a typing comment
from typing import Any, Generic, List, Optional, TypeVar, Tuple  # noqa

from qxbranch.quantum_feature_detector.circuit_base import CircuitBase
from qxbranch.quantum_feature_detector.quantum_transform import QuantumTransform
from qxbranch.quantum_feature_detector import logging_service

TBackend = TypeVar('TBackend', bound=Any)
TCircuit = TypeVar('TCircuit', bound=CircuitBase)


class CircuitGenerator(Generic[TBackend, TCircuit]):
    """
    Class used for generating random quantum circuits. Should be inherited from to create back-end specific circuits.

    The circuits are generated by first creating a connected graph with a vertex for each qubit desired. The edges of
    this graph are then used to position 2-qubit gates in the circuit and ensure that all qubits in the circuit are
    connected. Note that there may be more 2-qubit gates than are required to connect the circuit.

    Any remaining `gate_count` is used to generate 1-qubit gates.

    :param qubit_count: The number of qubits to use in the generated circuits.
    :param gate_count: The number of gates to use in the generated circuits. Must be greater than the qubit count, so
        that all qubits in the circuit can be connected.
    :param backend: The quantum back-end that will be used to run circuits generated by this class.
    :param one_qubit_gate_types: The names of single-qubit gates that can be used to generate circuits.
    :param two_qubit_gate_types: The names of two-qubit gates that can be used to generate circuits.
    :param edge_probability: Optional probability used to determine how often edges should appear in the graph used to
        generate circuits. Note that graphs must always be connected, so low probabilities may lead to long run-times as
        the generator tries to find a connected graph. Defaults to 0.4.
    :param random_instance: Optional random state used to seed the circuit generation.
    """
    def __init__(self, qubit_count: int, gate_count: int, backend: TBackend,
                 one_qubit_gate_types: Tuple[str, ...], two_qubit_gate_types: Tuple[str, ...],
                 edge_probability: float = 0.4, random_instance: Optional[random.Random] = None) -> None:
        self._logger = logging_service.get_logger(self.__class__.__name__)
        if random_instance is None:
            random_instance = random.Random()
        if qubit_count > gate_count:
            raise ValueError("Invalid circuit generation parameters: gate_count must be greater than qubit_count!")
        self._qubit_count = qubit_count
        self._gate_count = gate_count
        self._backend = backend
        self._one_qubit_gate_types = one_qubit_gate_types
        self._two_qubit_gate_types = two_qubit_gate_types
        self._edge_probability = edge_probability
        self._random_instance = random_instance

    def generate(self) -> TCircuit:
        """
        Generates a single randomly generated circuit of the type defined by the derived generator class.

        :return: A single randomly generated quantum circuit.
        """
        random_circuit = self._create_random_circuit()
        return self._generate_instance(random_circuit, qubit_count=self.qubit_count)

    def generate_multiple(self, circuit_count: int) -> Tuple[TCircuit, ...]:
        """
        Generates a tuple of randomly generated circuits of the type defined by the derived generator class.

        :return: A tuple of randomly generated quantum circuits.
        """
        return tuple([self.generate() for _ in range(circuit_count)])

    @abstractmethod
    def _generate_instance(self, random_circuit: Tuple[QuantumTransform, ...],
                           qubit_count: int) -> TCircuit:
        raise NotImplementedError("_generate_instance is unimplemented for this class.")

    def _create_random_circuit(self) -> Tuple[QuantumTransform, ...]:
        graph = self._create_random_connected_graph(self.qubit_count, self._random_instance)
        # Shuffle edges randomly to determine ordering of quantum gate
        # operations
        two_qubit_gates = list(graph.edges())  # type: List[Tuple[int, ...]]

        # Add additional 1 qubit gate operations - number of 1 qubit operations, for now,
        # will depend on the qubit_count
        single_qubit_gates = [tuple([self._random_instance.randint(0, self.qubit_count - 1)]) for _ in
                              range(self.gate_count - len(two_qubit_gates))]  # type: List[Tuple[int, ...]]

        # Add lists of 1 and 2 qubit gates together, shuffling
        edges = single_qubit_gates + two_qubit_gates
        self._random_instance.shuffle(edges)
        order_of_gates = list(range(len(edges)))

        random_circuit = []
        for i in order_of_gates:
            if len(edges[i]) == 1:
                gate_class = self._random_instance.choice(self.one_qubit_gate_types)
                # Go through edges and randomly make a quantum gate
                qubits = tuple([edges[i][0]])
            elif len(edges[i]) == 2:
                gate_class = self._random_instance.choice(self.two_qubit_gate_types)
                # Go through edges and randomly make a quantum gate
                qubits = tuple([edges[i][0], edges[i][1]])
            else:
                raise ValueError("Invalid edge")

            radians = self._random_instance.uniform(0, 2 * np.pi)
            random_circuit.append(QuantumTransform(gate_class, qubits, radians))

        return tuple(random_circuit)

    def _create_random_connected_graph(self, node_count: int, random_instance: random.Random) -> nx.Graph:
        self._logger.debug("Generating a random graph of size {}".format(node_count))
        graph = nx.fast_gnp_random_graph(n=node_count, p=0.4, seed=random_instance.randrange(65535))
        while not nx.is_connected(graph) or len(list(graph.edges())) > self.gate_count:
            graph = nx.fast_gnp_random_graph(n=node_count, p=0.4, seed=random_instance.randrange(65535))
        return graph

    @property
    def qubit_count(self) -> int:
        """The number of qubits in circuits generated by this class."""
        return self._qubit_count

    @property
    def gate_count(self) -> int:
        """The number of gates in circuits generated by this class."""
        return self._gate_count

    @property
    def backend(self) -> TBackend:
        """The quantum backend used to run circuits generated by this class."""
        return self._backend

    @property
    def one_qubit_gate_types(self) -> Tuple[str, ...]:
        """The names of the one-qubit gates that may be used in circuits generated by this class."""
        return self._one_qubit_gate_types

    @property
    def two_qubit_gate_types(self) -> Tuple[str, ...]:
        """The names of the two-qubit gates that may be used in circuits generated by this class."""
        return self._two_qubit_gate_types

    @property
    def edge_probability(self) -> float:
        """Controls the connectivity of the graph used to generate the circuit."""
        return self._edge_probability
