<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>midgard.config - Midgard v0.2.0</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/docco.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Midgard v0.2.0</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Home</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">How-to <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../howto/testing/">Testing</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">API <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../midgard/">midgard</a>
</li>
                                    
<li >
    <a href="../midgard-collections/">midgard.collections</a>
</li>
                                    
<li class="active">
    <a href="./">midgard.config</a>
</li>
                                    
<li >
    <a href="../midgard-data/">midgard.data</a>
</li>
                                    
<li >
    <a href="../midgard-dev/">midgard.dev</a>
</li>
                                    
<li >
    <a href="../midgard-files/">midgard.files</a>
</li>
                                    
<li >
    <a href="../midgard-gnss/">midgard.gnss</a>
</li>
                                    
<li >
    <a href="../midgard-ionosphere/">midgard.ionosphere</a>
</li>
                                    
<li >
    <a href="../midgard-math/">midgard.math</a>
</li>
                                    
<li >
    <a href="../midgard-parsers/">midgard.parsers</a>
</li>
                                    
<li >
    <a href="../midgard-plot/">midgard.plot</a>
</li>
                                    
<li >
    <a href="../midgard-site_info/">midgard.site_info</a>
</li>
                                    
<li >
    <a href="../midgard-writers/">midgard.writers</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../midgard-collections/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../midgard-data/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#midgardconfig">midgard.config</a></li>
            <li><a href="#midgardconfigconfig">midgard.config.config</a></li>
            <li><a href="#midgardconfigfiles">midgard.config.files</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="midgardconfig">midgard.config</h1>
<h2 id="midgardconfigconfig">midgard.config.config</h2>
<p>Midgard library module for handling of configuration settings</p>
<p><strong>Description:</strong></p>
<p>A Configuration consists of one or several sections. Each ConfigurationSection
consists of one or more entries. Each ConfigurationEntry consists of a key and
a value.</p>
<p><strong>Examples:</strong></p>
<p>For basic use, an entry is looked up by simple attribute access. For instance
if <code>cfg</code> is a Configuration with the section <code>midgard</code> which has an entry <code>foo
= bar</code>:</p>
<pre><code>&gt;&gt;&gt; cfg = Configuration("config_name")
&gt;&gt;&gt; cfg.update("midgard", "foo", "bar")
&gt;&gt;&gt; cfg.midgard.foo
ConfigurationEntry(key='foo', value='bar')
</code></pre>
<p>ConfigurationEntry has several access methods that convert the entry to a given
data type:</p>
<pre><code>&gt;&gt;&gt; cfg.update("midgard", "foo_pi", 3.14, source="command line")
&gt;&gt;&gt; cfg.midgard.foo_pi
ConfigurationEntry(key='foo_pi', value='3.14')
&gt;&gt;&gt; cfg.midgard.foo_pi.float
3.14
&gt;&gt;&gt; cfg.midgard.foo_pi.str
'3.14'
&gt;&gt;&gt; cfg.midgard.foo_pi.tuple
('3.14',)
</code></pre>
<p><strong>Sources:</strong></p>
<p>Each configuration entry records its source. That is, where that entry was
defined. Examples include read from file, set as a command line option, or
programmatically from a dictionary. The source can be looked up on an
individual entry, or for all entries in a configuration.</p>
<pre><code>&gt;&gt;&gt; cfg.midgard.foo_pi.source
'command line'
&gt;&gt;&gt; cfg.sources  # doctest: +SKIP
{'/home/midgard/midgard.conf', 'command line'}
</code></pre>
<p><strong>Profiles:</strong></p>
<p><strong>Fallback Configuration:</strong></p>
<p><strong>Master Section:</strong></p>
<p><strong>Replacement Variables:</strong></p>
<p><strong>Help text and Type hints:</strong></p>
<h3 id="casedconfigparser"><strong>CasedConfigParser</strong></h3>
<p>Full name: <code>midgard.config.config.CasedConfigParser</code></p>
<p>Signature: <code>(defaults=None, dict_type=&lt;class 'collections.OrderedDict'&gt;, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=&lt;object object at 0x7f1507871200&gt;, converters=&lt;object object at 0x7f1507871200&gt;)</code></p>
<p>ConfigParser with case-sensitive keys</p>
<h4 id="casedconfigparserboolean_states-dict">CasedConfigParser.BOOLEAN_STATES (dict)</h4>
<p><code>BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True, '0': False, 'no': False, 'false': False, 'off': False}</code></p>
<h4 id="casedconfigparsernonspacecre-sre_pattern">CasedConfigParser.NONSPACECRE (SRE_Pattern)</h4>
<p><code>NONSPACECRE = re.compile('\\S')</code></p>
<h4 id="casedconfigparseroptcre-sre_pattern">CasedConfigParser.OPTCRE (SRE_Pattern)</h4>
<p><code>OPTCRE = re.compile('\n        (?P&lt;option&gt;.*?)                    # very permissive!\n        \\s*(?P&lt;vi&gt;=|:)\\s*              # any number of space/tab,\n                                           # followed by any of t, re.VERBOSE)</code></p>
<h4 id="casedconfigparseroptcre_nv-sre_pattern">CasedConfigParser.OPTCRE_NV (SRE_Pattern)</h4>
<p><code>OPTCRE_NV = re.compile('\n        (?P&lt;option&gt;.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P&lt;vi&gt;=|:)\\s*                 # optionally followed , re.VERBOSE)</code></p>
<h4 id="casedconfigparsersectcre-sre_pattern">CasedConfigParser.SECTCRE (SRE_Pattern)</h4>
<p><code>SECTCRE = re.compile('\n        \\[                                 # [\n        (?P&lt;header&gt;[^]]+)                  # very permissive!\n        \\]                                 # ]\n        ', re.VERBOSE)</code></p>
<h4 id="casedconfigparseroptionxform">CasedConfigParser.<strong>optionxform</strong>()</h4>
<p>Full name: <code>midgard.config.config.optionxform</code></p>
<p>Signature: <code>(self, optionstr:str) -&gt; str</code></p>
<p>Do not turn optionstr (key) into lowercase</p>
<h3 id="configuration"><strong>Configuration</strong></h3>
<p>Full name: <code>midgard.config.config.Configuration</code></p>
<p>Signature: <code>(name:str) -&gt; None</code></p>
<p>Represents a Configuration</p>
<h4 id="configurationas_dict">Configuration.<strong>as_dict</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_dict</code></p>
<p>Signature: <code>(self, getters:Union[Dict[str, Dict[str, str]], NoneType]=None, default_getter:str='str') -&gt; Dict[str, Dict[str, Any]]</code></p>
<p>The configuration represented as a dictionary</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>getters</code>:         How to get the value of each entry in each section.</li>
<li><code>default_getter</code>:  How to get the value of entries not specified in getters.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Representation of the configuration as a nested dictionary.</p>
<h4 id="configurationas_str">Configuration.<strong>as_str</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_str</code></p>
<p>Signature: <code>(self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -&gt; str</code></p>
<p>The configuration represented as a string</p>
<p>This is simililar to what is shown by <code>str(configuration)</code> (and implemented by <code>__str__</code>), but has more
flexibility.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>width</code>:      Width of text for wrapping. Default is width of console.</li>
<li><code>key_width</code>:  Width of the key column. Default is 30 characters.</li>
<li><code>only_used</code>:  Only include configuration entries that has been used so far.</li>
<li><code>metadata</code>:   Include metadata like type and help text.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>String representation of the configuration.</p>
<h4 id="configurationclear">Configuration.<strong>clear</strong>()</h4>
<p>Full name: <code>midgard.config.config.clear</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Clear the configuration</p>
<h4 id="configurationclear_vars">Configuration.<strong>clear_vars</strong>()</h4>
<p>Full name: <code>midgard.config.config.clear_vars</code></p>
<p>Signature: <code>(self) -&gt; None</code></p>
<p>Clear the configuration variables</p>
<h4 id="configurationexists">Configuration.<strong>exists</strong>()</h4>
<p>Full name: <code>midgard.config.config.exists</code></p>
<p>Signature: <code>(self, key:str, section:Union[str, NoneType]=None) -&gt; bool</code></p>
<p>Check if a configuration entry exists</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>key</code>:      Name of option (key in the configuration entry).</li>
<li><code>section</code>:  Section in the configuration in which to look up the key.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>True if the configuration entry exists, otherwise False.</p>
<h4 id="configurationget">Configuration.<strong>get</strong>()</h4>
<p>Full name: <code>midgard.config.config.get</code></p>
<p>Signature: <code>(self, key:str, value:Union[str, NoneType]=None, section:Union[str, NoneType]=None, default:Union[str, NoneType]=None) -&gt; 'ConfigurationEntry'</code></p>
<p>Get an entry from a configuration with possibility for override and default value</p>
<p>A value for an entry is found using the following priorities:</p>
<pre><code>1. An explicit value given in `value`. None is used as a marker for no value.
2. Looked up in the current configuration.
3. Looked up in any fallback confiurations that are defined.
4. The default value is used.
</code></pre>
<p>If <code>value</code> is not None, that value is simply returned as a <code>ConfigurationEntry</code>. If <code>default</code> is not given (is
None), and a value is not found in any other way, a MissingEntryError is raised.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>key</code>:      Name of option (key in the configuration entry).</li>
<li><code>value</code>:    Value of entry. Used for overriding the configuration.</li>
<li><code>section</code>:  Section in the configuration in which to look up the key.</li>
<li><code>default</code>:  Default value that is returned if value is not found any other way.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Entry representing the value.</p>
<h4 id="configurationread_from_file">Configuration.<strong>read_from_file</strong>()</h4>
<p>Full name: <code>midgard.config.config.read_from_file</code></p>
<p>Signature: <code>(cfg_name:str, *file_paths:Union[str, pathlib.Path]) -&gt; 'Configuration'</code></p>
<p>Read a configuration from one or more files</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>file_paths</code>:  File(s) that will be read.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>A Configuration representing the file(s).</p>
<h4 id="configurationupdate">Configuration.<strong>update</strong>()</h4>
<p>Full name: <code>midgard.config.config.update</code></p>
<p>Signature: <code>(self, section:str, key:str, value:str, *, profile:Union[str, NoneType]=None, source:str='unknown', meta:Union[Dict[str, str], NoneType]=None, allow_new:bool=True, _update_sections:bool=True) -&gt; None</code></p>
<p>Update a configuration section with a configuration entry</p>
<p>If <code>allow_new</code> is False, the configuration entry must already exist. If it is True the update is allowed to
create a new section and a new entry is necessary.</p>
<p>The <code>_update_sections</code> flag can be used to not update the sections of the configuration, only the
profiles. This should typically not be done, but is used by some of the other update methods which update the
sections themselves.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>section</code>:    Section to update.</li>
<li><code>key</code>:        Key of entry.</li>
<li><code>value</code>:      Value of entry.</li>
<li><code>profile</code>:    Profile to update.</li>
<li><code>source</code>:     Source of the update.</li>
<li><code>meta</code>:       Metadata like help text and type hints for the entry.</li>
<li><code>allow_new</code>:  Whether to allow the creation of a new section and entry.</li>
</ul>
<h4 id="configurationupdate_from_config_section">Configuration.<strong>update_from_config_section</strong>()</h4>
<p>Full name: <code>midgard.config.config.update_from_config_section</code></p>
<p>Signature: <code>(self, other_section:'ConfigurationSection', section:Union[str, NoneType]=None, allow_new:bool=True) -&gt; None</code></p>
<h4 id="configurationupdate_from_dict">Configuration.<strong>update_from_dict</strong>()</h4>
<p>Full name: <code>midgard.config.config.update_from_dict</code></p>
<p>Signature: <code>(self, cfg_dict:Dict[str, Any], section:Union[str, NoneType]=None, source:str='dictionary', allow_new:bool=True) -&gt; None</code></p>
<h4 id="configurationupdate_from_file">Configuration.<strong>update_from_file</strong>()</h4>
<p>Full name: <code>midgard.config.config.update_from_file</code></p>
<p>Signature: <code>(self, file_path:Union[str, pathlib.Path], allow_new:bool=True, interpolate:bool=False, case_sensitive:bool=False) -&gt; None</code></p>
<p>Update the configuration from a configuration file</p>
<p>The Python ConfigParser is used to read the file. The file format that is supported is described at
https://docs.python.org/library/configparser.html</p>
<p>Different profiles in a configuration file are denoted by double underscores in the sections names. For
instance will the following configuration have a <code>foo</code> profile in the <code>spam</code> section (in addition to the
default profile):</p>
<pre><code>[spam]
...

[spam__foo]
...
</code></pre>
<p>The file may contain a special section called <code>__replace__</code> which may contain key-value pairs which will
replace format-style strings in keys and values in the rest of the file.</p>
<p>Additionally, the file may contain a special section called <code>__vars__</code>. The key-value pairs from this section
will be added to the <code>dictionary</code> of the configuration.</p>
<p>If <code>interpolate</code> is set to True, ExtendedInterpolation of variables in the configuration file is used. This
means that variables of the form ${key:section} can be used for references within the file. See
https://docs.python.org/library/configparser.html#configparser.ExtendedInterpolation for details.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>file_path</code>:      Path to the configuration file.</li>
<li><code>allow_new</code>:      Whether to allow the creation of new sections and entries.</li>
<li><code>interpolate</code>:    Whether to interpolate variables in the configuration file.</li>
<li><code>case_sensitive</code>: Whether to read keys as case sensitive (or convert to lower case).</li>
</ul>
<h4 id="configurationupdate_from_options">Configuration.<strong>update_from_options</strong>()</h4>
<p>Full name: <code>midgard.config.config.update_from_options</code></p>
<p>Signature: <code>(self, options:Union[List[str], NoneType]=None, profile:Union[str, NoneType]=None, source:str='command line', allow_new:bool=False) -&gt; None</code></p>
<h4 id="configurationupdate_on_file">Configuration.<strong>update_on_file</strong>()</h4>
<p>Full name: <code>midgard.config.config.update_on_file</code></p>
<p>Signature: <code>(file_path:Union[str, pathlib.Path], **as_str_args:Any) -&gt; Generator</code></p>
<p>Context manager for updating a configuration on file</p>
<h4 id="configurationupdate_vars">Configuration.<strong>update_vars</strong>()</h4>
<p>Full name: <code>midgard.config.config.update_vars</code></p>
<p>Signature: <code>(self, new_vars:Dict[str, str]) -&gt; None</code></p>
<p>Update the configuration variables</p>
<h4 id="configurationwrite_to_file">Configuration.<strong>write_to_file</strong>()</h4>
<p>Full name: <code>midgard.config.config.write_to_file</code></p>
<p>Signature: <code>(self, file_path:Union[str, pathlib.Path], **as_str_args:Any) -&gt; None</code></p>
<p>Write the configuration to a file</p>
<p>In addition to the file path, arguments can be specified and will be passed on to the as_str() function. See
<code>as_str()</code> for more information.</p>
<p>Todo: Use files.open_path</p>
<h3 id="configurationentry"><strong>ConfigurationEntry</strong></h3>
<p>Full name: <code>midgard.config.config.ConfigurationEntry</code></p>
<p>Signature: <code>(key:str, value:Any, *, source:str='', meta:Union[Dict[str, str], NoneType]=None, vars_dict:Union[Dict[str, str], NoneType]=None, _used_as:Union[Set[str], NoneType]=None) -&gt; None</code></p>
<h4 id="configurationentryas_bool">ConfigurationEntry.<strong>as_bool</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_bool</code></p>
<p>Signature: <code>(self) -&gt; bool</code></p>
<p>Value of ConfigurationEntry converted to a boolean</p>
<p>The conversion is done by looking up the string value of the entry in _BOOLEAN_STATES.</p>
<h4 id="configurationentryas_date">ConfigurationEntry.<strong>as_date</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_date</code></p>
<p>Signature: <code>(self, format:str='%Y-%m-%d') -&gt; datetime.date</code></p>
<p>Value of ConfigurationEntry converted to a date object</p>
<p><strong>Args:</strong></p>
<p>format (String):  Format string, see strftime for information about the string.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Date</code>:  Value of entry.</li>
</ul>
<h4 id="configurationentryas_datetime">ConfigurationEntry.<strong>as_datetime</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_datetime</code></p>
<p>Signature: <code>(self, format:str='%Y-%m-%d %H:%M:%S') -&gt; datetime.datetime</code></p>
<p>Value of ConfigurationEntry converted to a datetime object</p>
<p><strong>Args:</strong></p>
<p>format (String):  Format string, see strftime for information about the string.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Datetime</code>:  Value of entry.</li>
</ul>
<h4 id="configurationentryas_dict">ConfigurationEntry.<strong>as_dict</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_dict</code></p>
<p>Signature: <code>(self, item_split_re:str='[\\s,]', key_value_split_re:str='[:]', convert:Callable=&lt;class 'str'&gt;, maxsplit:int=0) -&gt; Dict[str, Any]</code></p>
<p>Value of ConfigurationEntry converted to a dictionary</p>
<p>By default the dictionary is created by splitting items at commas and whitespace,
and key from value at colons.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>item_split_re</code>:       Regular expression used to split entry into items.</li>
<li><code>key_value_split_re</code>:  Regular expression used to split items into keys and values.</li>
<li><code>convert</code>:             Function used to convert each value in the dictionary.</li>
<li><code>maxsplit</code>:            If nonzero, at most maxsplit splits occur when splitting entry into items.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Value of entry as dict.</p>
<h4 id="configurationentryas_enum">ConfigurationEntry.<strong>as_enum</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_enum</code></p>
<p>Signature: <code>(self, enum:str) -&gt; enum.Enum</code></p>
<p>Value of ConfigurationEntry converted to an enumeration</p>
<p><strong>Args:</strong></p>
<p>enum (String):   Name of Enum.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Enum</code>:  Value of entry as Enum.</li>
</ul>
<h4 id="configurationentryas_float">ConfigurationEntry.<strong>as_float</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_float</code></p>
<p>Signature: <code>(self) -&gt; float</code></p>
<p>Value of ConfigurationEntry converted to a float</p>
<h4 id="configurationentryas_int">ConfigurationEntry.<strong>as_int</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_int</code></p>
<p>Signature: <code>(self) -&gt; int</code></p>
<p>Value of ConfigurationEntry converted to an integer</p>
<h4 id="configurationentryas_list">ConfigurationEntry.<strong>as_list</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_list</code></p>
<p>Signature: <code>(self, split_re:str='[\\s,]', convert:Callable=&lt;class 'str'&gt;, maxsplit:int=0) -&gt; List[Any]</code></p>
<p>Value of ConfigurationEntry converted to a list</p>
<p>The entry is converted to a list by using the <code>split_re</code>-regular expression. By default the entry will be split
at commas and whitespace.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>split_re</code>:  Regular expression used to split entry into list.</li>
<li><code>convert</code>:   Function used to convert each element of the list.</li>
<li><code>maxsplit</code>:  If nonzero, at most maxsplit splits occur.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Value of entry as list.</p>
<h4 id="configurationentryas_list_of_lists">ConfigurationEntry.<strong>as_list_of_lists</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_list_of_lists</code></p>
<p>Signature: <code>(self, split_res:Tuple[str, ...]=('[\\s,]', '[^_\\w]'), num_elements:Union[int, NoneType]=None, convert:Callable=&lt;class 'str'&gt;) -&gt; List[List[Any]]</code></p>
<h4 id="configurationentryas_path">ConfigurationEntry.<strong>as_path</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_path</code></p>
<p>Signature: <code>(self) -&gt; pathlib.Path</code></p>
<p>Value of ConfigurationEntry interpreted as a path string</p>
<h4 id="configurationentryas_str">ConfigurationEntry.<strong>as_str</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_str</code></p>
<p>Signature: <code>(self) -&gt; str</code></p>
<p>Value of ConfigurationEntry as string</p>
<h4 id="configurationentryas_tuple">ConfigurationEntry.<strong>as_tuple</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_tuple</code></p>
<p>Signature: <code>(self, split_re:str='[\\s,]', convert:Callable=&lt;class 'str'&gt;, maxsplit:int=0) -&gt; Tuple[Any, ...]</code></p>
<p>Value of ConfigurationEntry converted to a tuple</p>
<p>The entry is converted to a tuple by using the <code>split_re</code>-regular expression. By default the entry will be
split at commas and whitespace.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>split_re</code>:  Regular expression used to split entry into tuple.</li>
<li><code>convert</code>:   Function used to convert each element of the tuple.</li>
<li><code>maxsplit</code>:  If nonzero, at most maxsplit splits occur.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Value of entry as tuple.</p>
<h4 id="configurationentryentry_as_str">ConfigurationEntry.<strong>entry_as_str</strong>()</h4>
<p>Full name: <code>midgard.config.config.entry_as_str</code></p>
<p>Signature: <code>(self, width:Union[int, NoneType]=None, key_width:int=30, metadata:bool=True) -&gt; str</code></p>
<p>The configuration entry represented as a string</p>
<p>This is simililar to what is shown by <code>str(entry)</code> (and implemented by <code>__str__</code>), but has more flexibility.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>width</code>:      Width of text for wrapping. Default is width of console.</li>
<li><code>key_width</code>:  Width of the key column. Default is 30 characters.</li>
<li><code>metadata</code>:   Include metadata like type and help text.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>String representation of the configuration entry.</p>
<h4 id="configurationentryreplace">ConfigurationEntry.<strong>replace</strong>()</h4>
<p>Full name: <code>midgard.config.config.replace</code></p>
<p>Signature: <code>(self, default:Union[str, NoneType]=None, **replace_vars:str) -&gt; 'ConfigurationEntry'</code></p>
<h3 id="configurationsection"><strong>ConfigurationSection</strong></h3>
<p>Full name: <code>midgard.config.config.ConfigurationSection</code></p>
<p>Signature: <code>(name:str) -&gt; None</code></p>
<h4 id="configurationsectionas_dict">ConfigurationSection.<strong>as_dict</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_dict</code></p>
<p>Signature: <code>(self, getters:Dict[str, str]=None, default_getter:str='str') -&gt; Dict[str, Any]</code></p>
<p>The configuration section represented as a dictionary</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>getters</code>:         How to get the value of each entry in the section.</li>
<li><code>default_getter</code>:  How to get the value of entries not specified in getters.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Representation of the configuration section as a dictionary.</p>
<h4 id="configurationsectionas_list">ConfigurationSection.<strong>as_list</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_list</code></p>
<p>Signature: <code>(self) -&gt; List[str]</code></p>
<p>List of keys of entries in configuration section</p>
<p><strong>Returns:</strong></p>
<p>List of keys of entries in configuration section.</p>
<h4 id="configurationsectionas_str">ConfigurationSection.<strong>as_str</strong>()</h4>
<p>Full name: <code>midgard.config.config.as_str</code></p>
<p>Signature: <code>(self, width:Union[int, NoneType]=None, key_width:int=30, only_used:bool=False, metadata:bool=True) -&gt; str</code></p>
<p>The configuration section represented as a string</p>
<p>This is simililar to what is shown by <code>str(section)</code> (and implemented by <code>__str__</code>), but has more flexibility.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>width</code>:      Width of text for wrapping. Default is width of console.</li>
<li><code>key_width</code>:  Width of the key column. Default is 30 characters.</li>
<li><code>only_used</code>:  Only include configuration entries that has been used so far.</li>
<li><code>metadata</code>:   Include metadata like type and help text.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>String representation of the configuration section.</p>
<h4 id="configurationsectionexists">ConfigurationSection.<strong>exists</strong>()</h4>
<p>Full name: <code>midgard.config.config.exists</code></p>
<p>Signature: <code>(self, key:str) -&gt; bool</code></p>
<p>Check if key exists in section</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>key</code>:  Name of configuration key.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>True if key is in section, False otherwise.</p>
<h3 id="fmt_date-str">FMT_date (str)</h3>
<p><code>FMT_date = '%Y-%m-%d'</code></p>
<h3 id="fmt_datetime-str">FMT_datetime (str)</h3>
<p><code>FMT_datetime = '%Y-%m-%d %H:%M:%S'</code></p>
<h3 id="fmt_dt_file-str">FMT_dt_file (str)</h3>
<p><code>FMT_dt_file = '%Y%m%d-%H%M%S'</code></p>
<h2 id="midgardconfigfiles">midgard.config.files</h2>
<p>Midgard library module for opening files based on a special configuration</p>
<p><strong>Example:</strong></p>
<pre><code>from midgard.config import files
with files.open('eopc04_iau', mode='rt') as fid:
    for line in fid:
        print(line.strip())
</code></pre>
<p><strong>Description:</strong></p>
<p>This module handles opening of files registered in a special configuration, typically a configuration file.</p>
<p>The cfg.files.open and cfg.files.open_path methods are both wrappers around the built-in open function, and behave
mainly similar. In particular, they accept all the same keyword arguments (like for instance mode). Furthermore, to
make sure files are properly closed they should normally be used with a context manager as in the example above.</p>
<h3 id="fileconfiguration"><strong>FileConfiguration</strong></h3>
<p>Full name: <code>midgard.config.files.FileConfiguration</code></p>
<p>Signature: <code>(name:str) -&gt; None</code></p>
<p>Configuration for handling files</p>
<h4 id="fileconfigurationdownload_file">FileConfiguration.<strong>download_file</strong>()</h4>
<p>Full name: <code>midgard.config.files.download_file</code></p>
<p>Signature: <code>(self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, file_path:Union[pathlib.Path, NoneType]=None, create_dirs:bool=True, **path_args:Any) -&gt; Union[pathlib.Path, NoneType]</code></p>
<p>Download a file from the web and save it to disk</p>
<p>Use pycurl (libcurl) to do the actual downloading. Requests might be
nicer for this, but turned out to be much slower (and in practice
unusable for bigger files) and also not really supporting
ftp-downloads.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>file_key</code>:     File key that should be downloaded.</li>
<li><code>file_vars</code>:    File variables used to find path from file_key.</li>
<li><code>file_path</code>:    Path where file will be saved, default is to read from configuration.</li>
<li><code>create_dirs</code>:  Create directories as necessary before downloading file.</li>
<li><code>path_args</code>:    Arguments passed on to .path() to find file_path.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Path to downloaded file, None if no file was downloaded.</p>
<h4 id="fileconfigurationdownload_missing-bool">FileConfiguration.download_missing (bool)</h4>
<p><code>download_missing = True</code></p>
<h4 id="fileconfigurationencoding">FileConfiguration.<strong>encoding</strong>()</h4>
<p>Full name: <code>midgard.config.files.encoding</code></p>
<p>Signature: <code>(self, file_key)</code></p>
<p>Look up the encoding for a given file key</p>
<p><strong>Args:</strong></p>
<p>file_key (String):  Key that is looked up in the configuration.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>String</code>:  Name of encoding. If encoding is not specified None is returned.</li>
</ul>
<h4 id="fileconfigurationglob_paths">FileConfiguration.<strong>glob_paths</strong>()</h4>
<p>Full name: <code>midgard.config.files.glob_paths</code></p>
<p>Signature: <code>(self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, is_zipped:Union[bool, NoneType]=None) -&gt; List[pathlib.Path]</code></p>
<p>Find all filepaths matching a filename pattern</p>
<p>Using pathlib.Path.glob() here is not trivial because we need to split
into a base directory to start searching from and a pattern which may
include directories. With glob.glob() this is trivial. The downside is
that it only returns strings and not pathlib.Paths.</p>
<h4 id="fileconfigurationglob_variable">FileConfiguration.<strong>glob_variable</strong>()</h4>
<p>Full name: <code>midgard.config.files.glob_variable</code></p>
<p>Signature: <code>(self, file_key, variable, pattern, file_vars=None)</code></p>
<p>Find all possible values of variable</p>
<h4 id="fileconfigurationis_path_zipped">FileConfiguration.<strong>is_path_zipped</strong>()</h4>
<p>Full name: <code>midgard.config.files.is_path_zipped</code></p>
<p>Signature: <code>(file_path)</code></p>
<p>Indicate whether a path is to a gzipped file or not</p>
<p>For now, this simply checks whether the path ends in .gz or not.</p>
<p><strong>Args:</strong></p>
<p>file_path (Path):  Path to a file.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Boolean</code>:   True if path is to a gzipped file, False otherwise.</li>
</ul>
<h4 id="fileconfigurationopen">FileConfiguration.<strong>open</strong>()</h4>
<p>Full name: <code>midgard.config.files.open</code></p>
<p>Signature: <code>(self, file_key:str, file_vars:Dict[str, str]=None, create_dirs:bool=False, is_zipped:Union[bool, NoneType]=None, download_missing:bool=True, use_aliases:bool=True, logger:Union[Callable, NoneType]=None, **open_args:Any) -&gt; Iterator</code></p>
<p>Open a file based on information in a configuration</p>
<p>Open a file based on file key which is looked up in the configuration.</p>
<p>The method automatically handles reading from gzipped files if the filename is specified with the special
{gz}-ending (including the curly braces) in the file list. In that case, the mode should be specified to be
'rt' if the contents of the file should be treated as text. If both a zipped and an unzipped version is
available, the zipped version is used. This can be overridden by specifying True or False for the
is_zipped-parameter.</p>
<p>This function behaves similar to the built-in open-function, and should typically be used with a context
manager as follows:</p>
<p>Example:</p>
<pre><code>with cfg.open('eopc04_iau', mode='rt') as fid:
    for line in fid:
        print(line.strip())
</code></pre>
<p><strong>Args:</strong></p>
<ul>
<li><code>file_key</code>:     String that is looked up in the configuration file list.</li>
<li><code>file_vars</code>:    Dict, extra variables used to replace variables in file name and path.</li>
<li><code>create_dirs</code>:  True or False, if True missing directories are created.</li>
<li><code>iz_zipped</code>:    None, True, or False. Whether the file</li>
<li><code>open_args</code>:    All keyword arguments are passed on to open_path.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>File object representing the file.</p>
<h4 id="fileconfigurationpath">FileConfiguration.<strong>path</strong>()</h4>
<p>Full name: <code>midgard.config.files.path</code></p>
<p>Signature: <code>(self, file_key:str, file_vars:Union[Dict[str, str], NoneType]=None, default:Union[str, NoneType]=None, is_zipped:Union[bool, NoneType]=None, download_missing:bool=False, use_aliases:bool=True) -&gt; pathlib.Path</code></p>
<p>Construct a filepath for a given file with variables</p>
<p>If <code>is_zipped</code> is None, and the file_path contains <code>&lt;filename&gt;{gz}</code>,
the file will be assumed to be a gzip-file if there exists a file named
<code>&lt;filename&gt;.gz</code>.</p>
<p>When setting <code>use_aliases</code> to True, the aliases as specified in the
files configuration file represent alternative filenames. In
particular:</p>
<pre><code>- if directory / file_name exists it is returned
- otherwise the first directory / alias that exists is returned
- if none of these exist, directory / file_name is returned
</code></pre>
<p><strong>Args:</strong></p>
<p>file_key (String):        Key that is looked up in the configuration.
file_vars (Dict):         Values used to replace variables in file name and path.
default (String):         Value to use for variables that are not in file_vars.
is_zipped (Bool/None):    True, False or None. If True, open with gzip. If None automatically decide.
download_missing (Bool):  Whether to try to download missing files.
use_aliases (Bool):       Fall back on aliases if file does not exist.</p>
<p>Return:
    Path: Full path with replaced variables in file name and path.</p>
<h4 id="fileconfigurationurl">FileConfiguration.<strong>url</strong>()</h4>
<p>Full name: <code>midgard.config.files.url</code></p>
<p>Signature: <code>(self, file_key, file_vars=None, default=None, is_zipped=None, use_aliases=False)</code></p>
<p>Construct a URL for a given file with variables</p>
<p>If <code>is_zipped</code> is None, and the url contains <code>&lt;filename&gt;{gz}</code>, the url
will be assumed to point to a gzip-file if there exists a file named
<code>&lt;filename&gt;.gz</code> on the server.</p>
<p><strong>Args:</strong></p>
<ul>
<li><code>file_key</code>:     Key that is looked up in the configuration.</li>
<li><code>file_vars</code>:    Values used to replace variables in file name and path.</li>
<li><code>default</code>:      Value to use for variables that are not in file_vars.</li>
<li><code>is_zipped</code>:    True, False or None. If True, open with gzip. If None automatically decide.</li>
<li><code>use_aliases</code>:  Fall back on aliases if URL does not exist - may be slow.</li>
</ul>
<p>Return:
    String: Full URL with replaced variables in file name and url.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
