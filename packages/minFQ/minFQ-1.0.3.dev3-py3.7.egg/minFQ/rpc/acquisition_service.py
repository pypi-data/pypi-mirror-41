### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .acquisition_pb2_grpc import *
from . import acquisition_pb2
from minFQ.rpc.acquisition_pb2 import *
from minFQ.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "AcquisitionService",
    "StartRequest",
    "StartResponse",
    "StopRequest",
    "StopResponse",
    "WatchForStatusChangeRequest",
    "WatchForStatusChangeResponse",
    "CurrentStatusRequest",
    "CurrentStatusResponse",
    "GetProgressRequest",
    "GetProgressResponse",
    "GetAcquisitionRunInfoRequest",
    "AcquisitionYieldSummary",
    "ChannelStateInfo",
    "AcquisitionConfigSummary",
    "AcquisitionRunInfo",
    "ListAcquisitionRunsRequest",
    "ListAcquisitionRunsResponse",
    "GetCurrentAcquisitionRunRequest",
    "WatchCurrentAcquisitionRunRequest",
    "MinknowStatus",
    "ERROR_STATUS",
    "READY",
    "STARTING",
    "PROCESSING",
    "FINISHING",
    "AcquisitionState",
    "ACQUISITION_STARTING",
    "ACQUISITION_RUNNING",
    "ACQUISITION_FINISHING",
    "ACQUISITION_COMPLETED",
    "AcquisitionStopReason",
    "STOPPED_NOT_SET",
    "STOPPED_USER_REQUESTED",
    "STOPPED_NO_DISK_SPACE",
    "STOPPED_DEVICE_STOPPED_ACQUISITION",
    "STOPPED_STARTING_ANOTHER_RUN",
    "STOPPED_PROTOCOL_ENDED",
    "STOPPED_DEVICE_ERROR",
]

class AcquisitionService(object):
    def __init__(self, channel):
        self._stub = AcquisitionServiceStub(channel)
        self._pb = acquisition_pb2

    def start(self, _message=None, _timeout=None, **kwargs):
        """
        Starts reading data from the device

        Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration, 
        calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency

        If acqusition is already running (even in the FINISHING state), this call will fail.

        On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
        See StopRequest.keep_power_on for more details about the implications of this.

        :param wait_until_processing:
            Defaults to false.
            If false will return as soon as minknow enters the STARTING state.
            If true then returns as soon as minknow enters the PROCESSING state.
        :param dont_wait_for_device_ready:
            Prevent waiting until the device is ready to start acquisition
            before starting acquisition. Defaults to false.

            MinKNOW will wait for a device and flowcell combination which is ready
            for acquisition for a reasonable timeout before starting acquisition.

            Since 1.14
        :rtype: StartResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.start(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StartRequest()

        if 'wait_until_processing' in kwargs:
            unused_args.remove('wait_until_processing')
            _message.wait_until_processing = kwargs['wait_until_processing']

        if 'dont_wait_for_device_ready' in kwargs:
            unused_args.remove('dont_wait_for_device_ready')
            _message.dont_wait_for_device_ready = kwargs['dont_wait_for_device_ready']

        if len(unused_args) > 0:
            raise ArgumentError("start got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.start(_message, timeout=_timeout), unwraps=[])

    def stop(self, _message=None, _timeout=None, **kwargs):
        """
        Stops data acquisition.

        Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
        description for documentation on what each mode does.

        Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
        So if starting a new experiment then you will have to wait for the READY state seperately

        :param data_action_on_stop:
        :param wait_until_ready:
            Defaults to false
            If false will return as soon as minknow enters the FINISHING state.
            If true then returns as soon as minknow enters the READY state.
        :param keep_power_on:
            Keep the ASIC power on for GridIONs and MinIONs.

            Unless this option is set to true, the ASIC power will be disabled as soon as MinKNOW has
            stopped pulling data from it. This is because removing (or plugging in) a flow cell while the
            power is on can damage it. Disabling the power will also disable the heating element; this is
            likely to cause the device to cool down (particularly for MinIONs).

            You should normally only use this option if you are expecting to start acquisition again
            in a short amount of time.

            This option has no effect on PromethIONs.

            Since 1.15.2
        :rtype: StopResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stop(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StopRequest()

        if 'data_action_on_stop' in kwargs:
            unused_args.remove('data_action_on_stop')
            _message.data_action_on_stop = kwargs['data_action_on_stop']

        if 'wait_until_ready' in kwargs:
            unused_args.remove('wait_until_ready')
            _message.wait_until_ready = kwargs['wait_until_ready']

        if 'keep_power_on' in kwargs:
            unused_args.remove('keep_power_on')
            _message.keep_power_on = kwargs['keep_power_on']

        if len(unused_args) > 0:
            raise ArgumentError("stop got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stop(_message, timeout=_timeout), unwraps=[])

    def watch_for_status_change(self, _iterator):
        return self._stub.watch_for_status_change(_iterator)

    def watch_current_acquisition_run(self, _message=None, _timeout=None, **kwargs):
        """
        Returns current acquisition run info and streams any changes to the current acquisition

        This call can be made even if there is no current protocol running. In this case, the next streamed
        response will be the start of a new acquisition and you will receive updates for that acquisition
        until it finishes.

        If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.

        Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.

        Since 1.13

        :rtype: AcquisitionRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.watch_current_acquisition_run(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = WatchCurrentAcquisitionRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("watch_current_acquisition_run got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.watch_current_acquisition_run(_message, timeout=_timeout), unwraps=[])

    def current_status(self, _message=None, _timeout=None, **kwargs):
        """
        Check the current status of MinKNOW.

        :rtype: CurrentStatusResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.current_status(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = CurrentStatusRequest()

        if len(unused_args) > 0:
            raise ArgumentError("current_status got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.current_status(_message, timeout=_timeout), unwraps=[])

    def get_progress(self, _message=None, _timeout=None, **kwargs):
        """
        Information on how much data has been acquired, processed and written.

        :rtype: GetProgressResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_progress(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetProgressRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_progress got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_progress(_message, timeout=_timeout), unwraps=[])

    def get_acquisition_info(self, _message=None, _timeout=None, **kwargs):
        """
        Gets information about an acquisition run, run within this instance on MinKNOW.

        If no run ID is provided, information about the most recently started acquisition run is
        provided.

        Since 1.11

        :param run_id:
            The protocol run to get information about.
        :rtype: AcquisitionRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_acquisition_info(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetAcquisitionRunInfoRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("get_acquisition_info got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_acquisition_info(_message, timeout=_timeout), unwraps=[])

    def list_acquisition_runs(self, _message=None, _timeout=None, **kwargs):
        """
        Gets information about all previous protocol runs.

        Since 1.11

        :rtype: ListAcquisitionRunsResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.list_acquisition_runs(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = ListAcquisitionRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("list_acquisition_runs got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.list_acquisition_runs(_message, timeout=_timeout), unwraps=[])

    def get_current_acquisition_run(self, _message=None, _timeout=None, **kwargs):
        """
        Returns the name and run id of the currently running acquisition.

        Will fail with FAILED_PRECONDITION if there is no acquisition running

        Since 1.11

        :rtype: AcquisitionRunInfo
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_current_acquisition_run(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetCurrentAcquisitionRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("get_current_acquisition_run got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_current_acquisition_run(_message, timeout=_timeout), unwraps=[])


