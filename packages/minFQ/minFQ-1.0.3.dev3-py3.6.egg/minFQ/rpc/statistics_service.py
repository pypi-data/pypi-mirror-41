### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
from .statistics_pb2_grpc import *
from . import statistics_pb2
from minFQ.rpc.statistics_pb2 import *
from minFQ.rpc._support import MessageWrapper, ArgumentError

__all__ = [
    "StatisticsService",
    "StreamDutyTimeRequest",
    "StreamDutyTimeResponse",
    "GetDutyTimeRequest",
    "GetDutyTimeResponse",
    "StreamReadLengthRequest",
    "StreamReadLengthResponse",
    "StreamHeatmapRequest",
    "StreamHeatmapResponse",
    "StreamCumulativeThroughputRequest",
    "CumulativeThroughputBucket",
    "StreamCumulativeThroughputResponse",
    "GetCumulativeThroughputRequest",
    "GetCumulativeThroughputResponse",
    "TimeUnit",
    "SECONDS",
    "MINUTES",
]

class StatisticsService(object):
    def __init__(self, channel):
        self._stub = StatisticsServiceStub(channel)
        self._pb = statistics_pb2

    def stream_duty_time(self, _message=None, _timeout=None, **kwargs):
        """
        Tracks how much time has been spent in each channel state, aggregated across all the channels

        Will fail with FAILED_PRECONDITION if minknow is not acquiring data unless `wait_for_processing` is set to True,
        then it will block and wait for data to start acquiring.

        The first response will give you all the data it can

        Since 1.13

        :param step: (required)
            Defines (in seconds) the bucket period of the duty time data

            Will fail with INVALID_ARGUMENT if `step` is below 60
            Will fail with INVALID_ARGUMENT if `step` is not a multiple of 60
            TODO: maximum size?
        :param start_time:
            Specify the start time of the data since the start time of the experiment (in seconds). If not specified then will return data since the start of the experiment

            Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)

            For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
            and the first bucket will be [600,660)
        :param end_time:
            Specify the end time of the data (in seconds). Call will return if the end time has been reached.
            If the end time has not yet been reached, then the stream will continue until it has, and then return.
            If not specified, then will stream forever
            If `end_time` is 0, then this will count as not specified and will stream forever

            Will fail with INVALID_ARGUMENT if not a multiple of `step`
            Will fail with INVALID_ARGUMENT if not more than `start_time`

            This specifies T1 for a bucket [T0, T1)
        :param wait_for_processing:
            If `wait_for_processing` is true, then will wait until minknow starts acquiring data instead
            of returning with an error

            Defaults to false
        :rtype: StreamDutyTimeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stream_duty_time(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StreamDutyTimeRequest()

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("stream_duty_time requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'wait_for_processing' in kwargs:
            unused_args.remove('wait_for_processing')
            _message.wait_for_processing = kwargs['wait_for_processing']

        if len(unused_args) > 0:
            raise ArgumentError("stream_duty_time got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stream_duty_time(_message, timeout=_timeout), unwraps=[])

    def get_duty_time(self, _message=None, _timeout=None, **kwargs):
        """
        Gets duty time information for a completed acquisition period.

        Currently, all time values must be given in multiples of 1 minute (it is recommended that the
        time unit is set to minutes).

        Since 1.14

        :param run_id: (required)
            The acquisition id of the experiment.
        :param step: (required)
            Defines the bucket period of the duty time data, in multiples of `time_unit`.
        :param start_time:
            Specify the start time of the data since the start time of the experiment in multiples of
            `time_unit`.

            Must be a multiple of `step`.

            If not specified then will return data since the start of the experiment.
        :param end_time:
            Specify the end time of the data to return in multiples of `time_unit`. Only data from before
            this time will be returned.

            This does not need to be a multiple of `step` - you will get a smaller final bucket if it is
            not.

            If not specified then will return all the data till the end of the experiment.
            A time past the end of the experiment will be accepted, and treated in the same way.
        :param time_unit:
            What unit of time are to use. Defaults to SECONDS

            This is used to interpret the other fields in this message as well as for the times in the
            response message.
        :rtype: GetDutyTimeResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_duty_time(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetDutyTimeRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("get_duty_time requires a 'run_id' argument")

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("get_duty_time requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'time_unit' in kwargs:
            unused_args.remove('time_unit')
            _message.time_unit = kwargs['time_unit']

        if len(unused_args) > 0:
            raise ArgumentError("get_duty_time got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_duty_time(_message, timeout=_timeout), unwraps=[])

    def stream_throughput(self, _message=None, _timeout=None, **kwargs):
        """
        Tracks experiment throughput across all channels over time

        The first response will give you all the data it can.

        The stream will end once the current acquisition period ends, and a caller will need to
        reinvoke the rpc in order to get new throughput data.

        Since 1.14

        :param step: (required)
            Defines (in seconds) the bucket period of the throughput

            The minimum size for `step` is 60
            TODO: maximum size?
        :param start_time:
            Specify the start time of the throughput data (in seconds). If not specified then will return data since the start of the experiment

            Will fail with INVALID_ARGUMENT if not a multiple of `step`. (TODO: maybe round to closest value instead of failing?)

            For example, if this was set to 600 with a step of 60, then the first 10 buckets will not be returned
            and the first bucket will be [600,660)
        :param end_time:
            Specify the end time of the data (in seconds). Call will return if the end time has been reached.
            If the end time has not yet been reached, then the stream will continue until it has, and then return.
            If not specified, then will stream forever

            Will fail with INVALID_ARGUMENT if not a multiple of `step`
            Will fail with INVALID_ARGUMENT if not more than `start_time`

            This specifies T1 for a bucket [T0, T1)
        :param wait_for_processing:
            If `wait_for_processing` is true, then will wait until minknow starts acquisiting data instead of returning with an error

            Defaults to false
        :rtype: StreamCumulativeThroughputResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.stream_throughput(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = StreamCumulativeThroughputRequest()

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("stream_throughput requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'wait_for_processing' in kwargs:
            unused_args.remove('wait_for_processing')
            _message.wait_for_processing = kwargs['wait_for_processing']

        if len(unused_args) > 0:
            raise ArgumentError("stream_throughput got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.stream_throughput(_message, timeout=_timeout), unwraps=[])

    def get_throughput(self, _message=None, _timeout=None, **kwargs):
        """
        Gets cumultative throughput information for a completed acquisition period.

        Currently, all time values must be given in multiples of 1 minute (it is recommended that the
        time unit is set to minutes).

        Since 1.14

        :param run_id: (required)
            The acquisition id of the experiment.
        :param step: (required)
            Defines the bucket period of the cumulative throughput data, in multiples of `time_unit`.
        :param start_time:
            Specify the start time of the data since the start time of the experiment in multiples of
            `time_unit`.

            Must be a multiple of `step`.

            If not specified then will return data since the start of the experiment.
        :param end_time:
            Specify the end time of the data to return in multiples of `time_unit`. Only data from before
            this time will be returned.

            This does not need to be a multiple of `step` - you will get a smaller final bucket if it is
            not.

            If not specified then will return all the data till the end of the experiment.
            A time past the end of the experiment will be accepted, and treated in the same way.
        :param time_unit:
            What unit of time are to use. Defaults to SECONDS

            This is used to interpret the other fields in this message as well as for the times in the
            response message.
        :rtype: GetCumulativeThroughputResponse
        """
        if _message is not None:
            return MessageWrapper(self._stub.get_throughput(_message, timeout=_timeout), unwraps=[])

        unused_args = set(kwargs.keys())

        _message = GetCumulativeThroughputRequest()

        if 'run_id' in kwargs:
            unused_args.remove('run_id')
            _message.run_id = kwargs['run_id']
        else:
            raise ArgumentError("get_throughput requires a 'run_id' argument")

        if 'step' in kwargs:
            unused_args.remove('step')
            _message.step = kwargs['step']
        else:
            raise ArgumentError("get_throughput requires a 'step' argument")

        if 'start_time' in kwargs:
            unused_args.remove('start_time')
            _message.start_time = kwargs['start_time']

        if 'end_time' in kwargs:
            unused_args.remove('end_time')
            _message.end_time = kwargs['end_time']

        if 'time_unit' in kwargs:
            unused_args.remove('time_unit')
            _message.time_unit = kwargs['time_unit']

        if len(unused_args) > 0:
            raise ArgumentError("get_throughput got unexpected keyword arguments '{}'".format("', '".join(unused_args)))
        return MessageWrapper(self._stub.get_throughput(_message, timeout=_timeout), unwraps=[])


