#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# ecnet/tools/tools.py
# v.2.1.1
# Developed in 2019 by Travis Kessler <travis.j.kessler@gmail.com>
#
# Contains various tools for database creation, MDL file creation, QSPR
# descriptor calculation
#

# Stdlib imports
from copy import deepcopy
from csv import writer, QUOTE_ALL, DictReader
from os import devnull, remove
from os.path import abspath, dirname, isfile, join
from re import compile, IGNORECASE
from shutil import rmtree, which
from subprocess import call

# ECNet imports
from ecnet import Server
from ecnet.data_utils import DataFrame

# 3rd party imports
from pubchempy import get_compounds

# Path to PaDEL is included in the package
_PADEL_PATH = join(
    dirname(abspath(__file__)),
    'PaDEL-Descriptor',
    'PaDEL-Descriptor.jar'
)


def predict_with_prj(input_txt, results_file, prj_file, form='name',
                     temp_db='_new_mols.csv', clean_up=True):
    '''Predicts values for supplied molecules using already-built ECNet project

    Args:
        input_txt (str): path to file containing either molecule names or
            SMILES (one entry per line)
        results_file (str): path to resulting CSV results file
        prj_file (str): path to already-built ECNet project
        form (str): `name` or `smiles` for selecting input format
        temp_db (str): path to temporary database generated by this function
        clean_up (bool): if True, cleans up all files generated during
            processing except for the input text files and output results
    '''

    sv = Server(project_file=prj_file, log_level='disable')
    input_names = sv.DataFrame.input_names
    create_db(input_txt, temp_db, form=form, clean_up=clean_up)
    new_data = DataFrame(temp_db)
    new_data.set_inputs(input_names)
    new_data.save(temp_db)
    sv.import_data(temp_db)
    sv.use_model(output_filename=results_file)
    if clean_up:
        remove(temp_db)
        rmtree(prj_file.replace('.prj', ''))


def create_db(input_txt, output_name, id_prefix='', targets=None, form='name',
              smiles_file='mols.smi', mdl_file='mols.mdl',
              desc_file='descriptors.csv', clean_up=True):
    '''Create an ECNet-formatted database from either molecule names or SMILES
    strings

    Args:
        input_txt (str): path to file containing either molecule names or
            SMILES (one entry per line)
        output_name (str): path to desired database file once created
        id_prefix (str): prefix for DATAID column entries, if supplied
        targets (str): path to file containing target values (optional)
        form (str): `name` or `smiles` for selecting input format
        smiles_file (str): if input format is not SMILES, this is the name of
            a temporary .smi file containing SMILES strings
        mdl_file (str): name of MDL file generated by Open Babel
        desc_file (str): name of descriptors file generated by PaDEL-Descriptor
        clean_up (bool): if True, cleans up all files generated during
            processing except for the input text files and output database
    '''

    input_data = _read_txt(input_txt)
    if form == 'name':
        input_names = deepcopy(input_data)
        for i, d in enumerate(input_data):
            input_data[i] = get_smiles(d)
        with open(smiles_file, 'w') as smi_file:
            for d in input_data:
                smi_file.write(d + '\n')
    elif form == 'smiles':
        input_names = ['' for _ in range(len(input_data))]
        smiles_file = input_txt

    else:
        raise ValueError('Unknown `format` argument: {}'.format(form))

    if targets is not None:
        target_data = _read_txt(targets)
        if len(target_data) != len(input_data):
            raise IndexError(
                'Number of targets does not equal the number of supplied'
                ' molecules: {}, {}'.format(
                    len(target_data), len(input_data)
                )
            )
    else:
        target_data = [0 for _ in range(len(input_data))]

    smiles_to_mdl(smiles_file, mdl_file)
    desc = mdl_to_descriptors(mdl_file, desc_file)
    desc_keys = list(desc[0].keys())
    try:
        desc_keys.remove('Name')
    except:
        pass

    valid_keys = []
    for ds in desc_keys:
        is_valid = True
        for row in desc[1:]:
            if row[ds] == '' or row[ds] is None:
                row[ds] = 0
        if is_valid:
            valid_keys.append(ds)
    desc_keys = valid_keys

    rows = []
    type_row = ['DATAID', 'ASSIGNMENT', 'STRING', 'STRING', 'TARGET']
    type_row.extend(['INPUT' for _ in range(len(desc_keys))])
    title_row = ['DATAID', 'ASSIGNMENT', 'Compound Name', 'SMILES', 'Target']
    title_row.extend(desc_keys)
    rows.append(type_row)
    rows.append(title_row)

    for idx, name in enumerate(input_names):
        mol_row = [
            '{}'.format(id_prefix) + '%04d' % (idx + 1),
            'L',
            name,
            input_data[idx],
            target_data[idx]
        ]
        mol_row.extend([desc[idx][k] for k in desc_keys])
        rows.append(mol_row)

    with open(output_name, 'w', encoding='utf-8') as new_db:
        wr = writer(new_db, quoting=QUOTE_ALL, lineterminator='\n')
        for row in rows:
            wr.writerow(row)

    if clean_up:
        if form != 'smiles':
            remove(smiles_file)
        remove(mdl_file)
        remove(desc_file)


def _read_txt(file):
    '''Reads text file, returns contents

    Args:
        file (str): path to file

    Returns:
        list: each line in the text file is a list element
    '''

    with open(file, 'r') as txt_file:
        return txt_file.read().split('\n')


def get_smiles(name):
    '''Queries PubChemPy for SMILES string for supplied molecule

    Args:
        name (str): name of the molecule

    Returns:
        str or None: if molecule found, returns first idenitifying SMILES,
            else None
    '''

    smiles = [m.isomeric_smiles for m in get_compounds(name, 'name')]
    if len(smiles) == 0:
        raise IndexError('PubChem entry not found for {}'.format(name))
    else:
        return smiles[0]


def smiles_to_mdl(smiles_file, mdl_file):
    '''Invoke Open Babel to generate an MDL file containing all supplied
    molecules; requires Open Babel to be installed externally

    Args:
        smiles_file (str): path to .smi file (text file) with SMILES strings
        mdl_file (str): path to resulting MDL file
    '''

    if which('obabel') is None:
        raise ReferenceError('Open Babel installation not found')

    is_mdl = compile(r'.*\.mdl$', IGNORECASE)
    if is_mdl.match(mdl_file) is None:
        raise ValueError('Output file must have an MDL extension: {}'.format(
            mdl_file
        ))

    dn = open(devnull, 'w')
    for attempt in range(3):
        try:
            call([
                'obabel',
                '-i',
                'smi',
                smiles_file,
                '-o',
                'mdl',
                '-O',
                mdl_file,
                '--gen3D'
            ], stdout=dn, stderr=dn, timeout=3600)
            break
        except Exception as e:
            if attempt == 2:
                raise e
            else:
                continue


def mdl_to_descriptors(mdl_file, descriptors_csv):
    '''Generates QSPR descriptors from supplied MDL file using
    PaDEL-Descriptor

    Args:
        mdl_file (str): path to source MDL file
        descriptors_csv (str): path to resulting CSV file w/ descriptors

    Returns:
        list: list of dicts, where each dict is a molecule populated with
            descriptor names (keys) and values
    '''

    if which('java') is None:
        raise ReferenceError(
            'Java JRE 6+ not found (required for PaDEL-Descriptor)'
        )

    dn = open(devnull, 'w')
    for attempt in range(3):
        try:
            call([
                'java',
                '-jar',
                _PADEL_PATH,
                '-2d',
                '-3d',
                '-retainorder',
                '-retain3d',
                '-dir',
                mdl_file,
                '-file',
                descriptors_csv
            ], stdout=dn, stderr=dn, timeout=3600)
            break
        except Exception as e:
            if attempt == 2:
                raise e
            else:
                continue

    with open(descriptors_csv, 'r', encoding='utf-8') as desc_file:
        reader = DictReader(desc_file)
        return [row for row in reader]
