import datetime
import functools
import json
import operator
import uuid

import attr
import decimal
import pytz
from dateutil.parser import parse

from attr.validators import optional

from . import from_dict, to_dict

from .constants import (
    DESERIALISE,
    IS_DEFAULT_FROM_ATTR,
    IS_KEY,
    IS_ONLY_FIELD,
    IS_PK,
    IS_UNIQUE,
    MISSING,
    SELF,
    SERIALISE,
    SHOULD_SERIALISE,
    SUBTYPE,
    TYPE,
)
from .kind import UnionKind, union_parts, wrap_kind
from .options import SerdeOptions
from .reflect import field_subtype, field_type
from .validators import all_of, collection_of, instance_of


# We do this dance for ease of testing, because new_uuid gets wrapped before
# any patching is possible
def _new_uuid():
    return uuid.uuid4().hex


def _check_bool(v, name):
    """ Check `v` is actually a bool and raise ValueError if not """
    if not isinstance(v, bool):
        raise ValueError(f'`{name}` must be a boolean value')


def new_uuid():
    return _new_uuid()


def primary_key(kind=str,
                *,
                auto=False,
                auto_func=MISSING,
                serialise=MISSING,
                deserialise=MISSING,
                _pid_ok=False):
    """
    Indicate that a field is a primary key, setting the appropriate metadata
    Args:
        kind: The class to use for the primary key
        auto: If true, then string values will be autogenerated
            by calling `auto_func`
        auto_func: a 0-arity function to generate IDs.
    Returns:

    """
    if auto_func is MISSING:
        auto_func = new_uuid
    else:
        auto = True

    if auto:
        default = attr.Factory(auto_func)
    else:
        default = MISSING
    return key(
        kind,
        is_pk=True,
        default=default,
        serialise=serialise,
        deserialise=deserialise,
        _pid_ok=_pid_ok,
    )


def key(kind,
        validator=MISSING,
        default=MISSING,
        unique=False,
        is_optional=False,
        factory=MISSING,
        should_serialise=True,
        is_pk=False,
        serialise=MISSING,
        deserialise=MISSING,
        _pid_ok=False):
    """
    Indicate that a field is a key, setting the appropriate metadata.
    Args:
        kind: The class to use for the key. Class or string.
        validator (:func:): A validator to wrap the instance check with
            (you might want to pass `attr.validators.optional` here for
            example)
        default: The default value to use

    Returns:

    """
    return _field(
        kind,
        validator=validator,
        default=default,
        should_serialise=should_serialise,
        is_optional=is_optional,
        is_key=True,
        factory=factory,
        is_pk=is_pk,
        unique=unique,
        serialise=serialise,
        deserialise=deserialise)


@wrap_kind()
def object_field(kind,
                 *,
                 validator=MISSING,
                 is_optional=False,
                 default=MISSING,
                 factory=MISSING,
                 should_serialise=True,
                 is_only_field=False):
    return _field(
        kind,
        validator=validator,
        is_optional=is_optional,
        default=default,
        factory=factory,
        should_serialise=should_serialise,
        deserialise=_deserialise_maybe_union,
        is_only_field=is_only_field,
    )


@wrap_kind(kwarg_names=('subtype', ))
def _field(kind,
           *,
           unique=False,
           validator=MISSING,
           is_optional=False,
           default=MISSING,
           factory=MISSING,
           serialise=MISSING,
           deserialise=MISSING,
           should_serialise=True,
           is_pk=False,
           is_key=False,
           subtype=MISSING,
           default_from_attr=MISSING,
           is_only_field=False,
           convert=MISSING):
    """
    Basic wrapper for attr.ib.

    Note that unique is purely informational at this level - it's up to the
    data persistence layer to do something about it.
    """
    if kind:
        v = instance_of(kind)
    else:

        def v(inst, attr, value):
            return True

    # Check boolean fields actually are boolean
    _check_bool(unique, 'unique')
    _check_bool(is_optional, 'is_optional')
    _check_bool(should_serialise, 'should_serialise')
    _check_bool(is_pk, 'is_pk')
    _check_bool(is_key, 'is_key')
    _check_bool(is_only_field, 'is_only_field')

    # Non-serialisable fields are by definition optional (else we wouldn't
    # be able to deserialise them...). We also have to wrap any explicitly-
    # provided validator in optional, otherwise it will be invoked on None.
    if is_optional or not should_serialise:
        v = optional(v)
        if validator is not MISSING:
            validator = optional(validator)

    if validator is not MISSING:
        v = all_of(v, validator)

    attrkid_metadata = {
        TYPE: kind,
        IS_UNIQUE: unique,
        SHOULD_SERIALISE: should_serialise,
        IS_KEY: is_key or is_pk,
        IS_PK: is_pk,
        IS_DEFAULT_FROM_ATTR: default_from_attr is not MISSING,
        IS_ONLY_FIELD: is_only_field,
    }

    kw = {'validator': v, 'metadata': attrkid_metadata}

    if default_from_attr is not MISSING:
        if default is not MISSING:
            raise TypeError(
                'default cannot be specified with default_from_attr')
        default = attr.Factory(
            operator.attrgetter(default_from_attr), takes_self=True)

    if default is not MISSING:
        kw['default'] = default
    if factory is not MISSING:
        kw['factory'] = factory
    if not should_serialise:
        kw['default'] = None
    if convert is not MISSING:
        kw['convert'] = convert
    if serialise is not MISSING:
        attrkid_metadata[SERIALISE] = serialise
    if deserialise is not MISSING:
        attrkid_metadata[DESERIALISE] = deserialise
    if subtype is not MISSING:
        attrkid_metadata[SUBTYPE] = subtype

    return attr.ib(**kw)


def _deserialise_list_of(collection_type, kind, owning_cls, field, value):
    """
    Deserialise a list of items into a collection objects of class `kind`. Note
    that if the value is None, we return None here so that we get a more
    meaningful error message later on.

    Args:
        kind: Type to deserialise into
        value: List of raw items
        collection_type: The type of the container (list, set, etc)

    Returns:
        Collection of deserialized items, or None (if value was None)
    """
    if value is None:
        return None
    # TODO(dan): Is this json stuff necessary?
    if isinstance(value, (bytes, str)):
        value = json.loads(value)

    result = [
        _deserialise_maybe_union(owning_cls, field, each) for each in value
    ]
    return collection_type(result)


def _collection_field(collection_type,
                      kind,
                      *,
                      validator=MISSING,
                      should_serialise=True,
                      default_from_attr=MISSING,
                      is_only_field=False,
                      is_optional=False,
                      default=MISSING,
                      convert=MISSING,
                      deserialise=MISSING):
    v = collection_of(kind)
    if validator is not MISSING:
        v = all_of(v, validator)

    # default_from_attr provides its own default
    if default_from_attr is MISSING and default is MISSING:
        default = attr.Factory(collection_type)

    if deserialise is MISSING:
        deserialise = functools.partial(_deserialise_list_of, collection_type,
                                        kind)

    def _serialise(field, value, *, options: SerdeOptions = None):
        # In dict form, we represent all collection types as lists. We
        # can't use the native type, because you can't store a dict in a
        # set (dicts are unhashable).
        return [to_dict(contained, options=options) for contained in value]

    return _field(
        collection_type,
        validator=v,
        default=default,
        deserialise=deserialise,
        subtype=kind,
        is_only_field=is_only_field,
        is_optional=is_optional,
        should_serialise=should_serialise,
        default_from_attr=default_from_attr,
        convert=convert,
        serialise=_serialise)


@wrap_kind()
def list_field(kind,
               *,
               validator=MISSING,
               should_serialise=True,
               is_only_field=False,
               sort_key=None,
               sort_reverse=False):
    # If we've been given a sort key function, create an attr converter
    # that will sort the value by the given key
    if sort_key is not None:
        sort_converter = functools.partial(
            sorted, key=sort_key, reverse=sort_reverse)
    else:
        sort_converter = MISSING

    return _collection_field(
        list,
        kind,
        validator=validator,
        should_serialise=should_serialise,
        is_only_field=is_only_field,
        convert=sort_converter)


@wrap_kind()
def tuple_field(kind,
                *,
                validator=MISSING,
                should_serialise=True,
                is_optional=False,
                is_only_field=False,
                default=()):
    return _collection_field(
        tuple,
        kind,
        validator=validator,
        should_serialise=should_serialise,
        is_optional=is_optional,
        default=default,
        is_only_field=is_only_field)


@wrap_kind()
def set_field(kind,
              *,
              validator=MISSING,
              should_serialise=True,
              default_from_attr=MISSING):

    # With sets, we always convert to a frozenset as they're hashable.
    return _collection_field(
        frozenset,
        kind,
        validator=validator,
        should_serialise=should_serialise,
        default_from_attr=default_from_attr,
        convert=frozenset)


def _deserialise_maybe_union(owning_cls, field, value):
    if value is not None:
        maybe_typ, = field_subtype(field, unwrap=False, default=(None, ))
        if maybe_typ is None:
            typ, = field_type(field, unwrap=False)
        else:
            typ = maybe_typ
        if isinstance(typ, UnionKind):
            final_kind, value = union_parts(typ, value)
        else:
            # This is safe, because only UnionKind returns multiple
            # types in its `get()`.
            final_kind, = typ.get()
            if final_kind is SELF:
                final_kind = owning_cls

        return from_dict(final_kind, value)
    else:
        return None


def any_field(*,
              validator=MISSING,
              is_optional=False,
              default=MISSING,
              factory=MISSING,
              should_serialise=True):
    return _field(
        None,
        validator=validator,
        is_optional=is_optional,
        default=default,
        factory=factory,
        should_serialise=should_serialise)


def string_field(*,
                 unique=False,
                 validator=MISSING,
                 is_optional=False,
                 default=MISSING,
                 factory=MISSING,
                 should_serialise=True,
                 default_from_attr=MISSING):
    return _field(
        str,
        unique=unique,
        validator=validator,
        is_optional=is_optional,
        default=default,
        factory=factory,
        should_serialise=should_serialise,
        default_from_attr=default_from_attr,
    )


def url_field(*,
              unique=False,
              is_optional=False,
              default=MISSING,
              factory=MISSING,
              should_serialise=True,
              default_from_attr=MISSING,
              validator=MISSING):

    def is_secure(instance, attribute, value):
        if value and not value.lower().startswith('https://'):
            raise ValueError('An https URL is required')

    if validator is not MISSING:
        validator = all_of(validator, is_secure)
    else:
        validator = is_secure

    return string_field(
        unique=unique,
        is_optional=is_optional,
        default=default,
        factory=factory,
        should_serialise=should_serialise,
        default_from_attr=default_from_attr,
        validator=validator,
    )


def datetime_field(*,
                   default=MISSING,
                   factory=MISSING,
                   validator=MISSING,
                   is_optional=False):

    def _parse_datetime(owning_cls, field, v):
        if v is None:
            return None
        if isinstance(v, datetime.datetime):
            # TODO(dan): Ensure timezone is populated with UTC
            return v
        else:
            return parse(v).replace(tzinfo=pytz.utc)

    def _serialise_datetime(field, value, *, options: SerdeOptions):
        if isinstance(value, datetime.datetime) and options.convert_datetimes:
            value = value.strftime(options.datetime_format)
        return value

    return _field(
        datetime.datetime,
        validator=validator,
        is_optional=is_optional,
        default=default,
        factory=factory,
        deserialise=_parse_datetime,
        serialise=_serialise_datetime)


def int_field(*,
              default=MISSING,
              factory=MISSING,
              validator=MISSING,
              is_optional=False):
    return _field(
        int,
        validator=validator,
        factory=factory,
        is_optional=is_optional,
        default=default,
    )


def float_field(*,
                default=MISSING,
                factory=MISSING,
                validator=MISSING,
                is_optional=False):
    return _field(
        float,
        validator=validator,
        factory=factory,
        is_optional=is_optional,
        default=default,
    )


def decimal_field(*,
                  prec=MISSING,
                  validator=MISSING,
                  is_optional=False,
                  factory=MISSING,
                  default=MISSING):

    def _deserialise_decimal(owning_cls, field, v):
        if prec is not MISSING:
            decimal_context = decimal.Context(prec=prec)
        else:
            decimal_context = decimal.Context()
        return decimal.Decimal(v, context=decimal_context)

    def _serialise_decimal(field, value, *, options: SerdeOptions):
        return str(value)

    return _field(
        decimal.Decimal,
        validator=validator,
        is_optional=is_optional,
        default=default,
        factory=factory,
        serialise=_serialise_decimal,
        deserialise=_deserialise_decimal,
    )


def bool_field(*,
               default=MISSING,
               validator=MISSING,
               factory=MISSING,
               is_optional=False,
               should_serialise=True):
    return _field(
        bool,
        validator=validator,
        is_optional=is_optional,
        default=default,
        factory=factory,
        should_serialise=should_serialise)


def bytes_field(*,
                default=MISSING,
                validator=MISSING,
                factory=MISSING,
                is_optional=False,
                should_serialise=True):
    return _field(
        bytes,
        validator=validator,
        is_optional=is_optional,
        factory=factory,
        default=default,
        should_serialise=should_serialise,
    )
