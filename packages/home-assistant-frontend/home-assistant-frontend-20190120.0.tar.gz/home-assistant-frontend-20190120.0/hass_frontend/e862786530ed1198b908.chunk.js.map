{"version":3,"file":"e862786530ed1198b908.chunk.js","sources":["webpack:///e862786530ed1198b908.chunk.js"],"sourcesContent":["(window.webpackJsonp=window.webpackJsonp||[]).push([[106,9],{170:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return superstruct});class StructError extends TypeError{static format(attrs){const{type,path,value}=attrs,message=`Expected a value of type \\`${type}\\`${path.length?` for \\`${path.join(\".\")}\\``:\"\"} but received \\`${JSON.stringify(value)}\\`.`;return message}constructor(attrs){const message=StructError.format(attrs);super(message);const{data,path,value,reason,type,errors=[]}=attrs;this.data=data;this.path=path;this.value=value;this.reason=reason;this.type=type;this.errors=errors;if(!errors.length){errors.push(this)}if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}else{this.stack=new Error().stack}}}var toString=Object.prototype.toString,kindOf=function(val){if(void 0===val)return\"undefined\";if(null===val)return\"null\";var type=typeof val;if(\"boolean\"===type)return\"boolean\";if(\"string\"===type)return\"string\";if(\"number\"===type)return\"number\";if(\"symbol\"===type)return\"symbol\";if(\"function\"===type){return isGeneratorFn(val)?\"generatorfunction\":\"function\"}if(isArray(val))return\"array\";if(isBuffer(val))return\"buffer\";if(isArguments(val))return\"arguments\";if(isDate(val))return\"date\";if(isError(val))return\"error\";if(isRegexp(val))return\"regexp\";switch(ctorName(val)){case\"Symbol\":return\"symbol\";case\"Promise\":return\"promise\";case\"WeakMap\":return\"weakmap\";case\"WeakSet\":return\"weakset\";case\"Map\":return\"map\";case\"Set\":return\"set\";case\"Int8Array\":return\"int8array\";case\"Uint8Array\":return\"uint8array\";case\"Uint8ClampedArray\":return\"uint8clampedarray\";case\"Int16Array\":return\"int16array\";case\"Uint16Array\":return\"uint16array\";case\"Int32Array\":return\"int32array\";case\"Uint32Array\":return\"uint32array\";case\"Float32Array\":return\"float32array\";case\"Float64Array\":return\"float64array\";}if(isGeneratorObj(val)){return\"generator\"}type=toString.call(val);switch(type){case\"[object Object]\":return\"object\";case\"[object Map Iterator]\":return\"mapiterator\";case\"[object Set Iterator]\":return\"setiterator\";case\"[object String Iterator]\":return\"stringiterator\";case\"[object Array Iterator]\":return\"arrayiterator\";}return type.slice(8,-1).toLowerCase().replace(/\\s/g,\"\")};function ctorName(val){return val.constructor?val.constructor.name:null}function isArray(val){if(Array.isArray)return Array.isArray(val);return val instanceof Array}function isError(val){return val instanceof Error||\"string\"===typeof val.message&&val.constructor&&\"number\"===typeof val.constructor.stackTraceLimit}function isDate(val){if(val instanceof Date)return!0;return\"function\"===typeof val.toDateString&&\"function\"===typeof val.getDate&&\"function\"===typeof val.setDate}function isRegexp(val){if(val instanceof RegExp)return!0;return\"string\"===typeof val.flags&&\"boolean\"===typeof val.ignoreCase&&\"boolean\"===typeof val.multiline&&\"boolean\"===typeof val.global}function isGeneratorFn(name){return\"GeneratorFunction\"===ctorName(name)}function isGeneratorObj(val){return\"function\"===typeof val.throw&&\"function\"===typeof val.return&&\"function\"===typeof val.next}function isArguments(val){try{if(\"number\"===typeof val.length&&\"function\"===typeof val.callee){return!0}}catch(err){if(-1!==err.message.indexOf(\"callee\")){return!0}}return!1}function isBuffer(val){if(val.constructor&&\"function\"===typeof val.constructor.isBuffer){return val.constructor.isBuffer(val)}return!1}const IS_STRUCT=\"@@__STRUCT__@@\",KIND=\"@@__KIND__@@\";function isStruct(value){return!!(value&&value[IS_STRUCT])}function resolveDefaults(defaults,value){return\"function\"===typeof defaults?defaults(value):defaults}var _extends=Object.assign||function(target){for(var i=1,source;i<arguments.length;i++){source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};class Kind{constructor(name,type,validate){this.name=name;this.type=type;this.validate=validate}}function any(schema,defaults$$1,options){if(isStruct(schema)){return schema[KIND]}if(schema instanceof Kind){return schema}switch(kindOf(schema)){case\"array\":{return 1<schema.length?tuple(schema,defaults$$1,options):list(schema,defaults$$1,options)}case\"function\":{return func(schema,defaults$$1,options)}case\"object\":{return object(schema,defaults$$1,options)}case\"string\":{let required=!0,type;if(schema.endsWith(\"?\")){required=!1;schema=schema.slice(0,-1)}if(schema.includes(\"|\")){const scalars=schema.split(/\\s*\\|\\s*/g);type=union(scalars,defaults$$1,options)}else if(schema.includes(\"&\")){const scalars=schema.split(/\\s*&\\s*/g);type=intersection(scalars,defaults$$1,options)}else{type=scalar(schema,defaults$$1,options)}if(!required){type=optional(type,void 0,options)}return type}}throw new Error(`Invalid schema: ${schema}`)}function en(schema,defaults$$1){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const type=schema.map(s=>{try{return JSON.stringify(s)}catch(e){return s+\"\"}}).join(\" | \");return new Kind(\"enum\",type,(value=resolveDefaults(defaults$$1))=>{return schema.includes(value)?[void 0,value]:[{data:value,path:[],value,type}]})}function func(schema,defaults$$1){if(\"function\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const type=\"<function>\";return new Kind(\"function\",type,(value=resolveDefaults(defaults$$1),data)=>{const result=schema(value,data);let failure={path:[],reason:null},isValid;switch(kindOf(result)){case\"boolean\":{isValid=result;break}case\"string\":{isValid=!1;failure.reason=result;break}case\"object\":{isValid=!1;failure=_extends({},failure,result);break}default:{throw new Error(`Invalid result: ${result}`)}}return isValid?[void 0,value]:[_extends({type,value,data:value},failure)]})}function list(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)||1!==schema.length){throw new Error(`Invalid schema: ${schema}`)}const array=scalar(\"array\",void 0,options),element=any(schema[0],void 0,options),type=`[${element.type}]`;return new Kind(\"list\",type,(value=resolveDefaults(defaults$$1))=>{const[error,result]=array.validate(value);if(error){error.type=type;return[error]}value=result;const errors=[],ret=[];for(let i=0;i<value.length;i++){const v=value[i],[e,r]=element.validate(v);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[i].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}ret[i]=r}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})}function object(schema,defaults$$1,options){if(\"object\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const obj=scalar(\"object\",void 0,options),ks=[],properties={};for(const key in schema){ks.push(key);const s=schema[key],kind=any(s,void 0,options);properties[key]=kind}const type=`{${ks.join()}}`;return new Kind(\"object\",type,(value=resolveDefaults(defaults$$1))=>{const[error]=obj.validate(value);if(error){error.type=type;return[error]}const errors=[],ret={},valueKeys=Object.keys(value),propertiesKeys=Object.keys(properties),keys=new Set(valueKeys.concat(propertiesKeys));keys.forEach(key=>{let v=value[key];const kind=properties[key];if(v===void 0){const d=defaults$$1&&defaults$$1[key];v=resolveDefaults(d,value)}if(!kind){const e={data:value,path:[key],value:v};errors.push(e);return}const[e,r]=kind.validate(v,value);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[key].concat(singleE.path);singleE.data=value;errors.push(singleE)});return}if(key in value||r!==void 0){ret[key]=r}});if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})}function optional(schema,defaults$$1,options){return union([schema,\"undefined\"],defaults$$1,options)}function scalar(schema,defaults$$1,options){if(\"string\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const{types}=options,fn=types[schema];if(\"function\"!==kindOf(fn)){throw new Error(`Invalid type: ${schema}`)}const kind=func(fn,defaults$$1,options),type=schema;return new Kind(\"scalar\",type,value=>{const[error,result]=kind.validate(value);if(error){error.type=type;return[error]}return[void 0,result]})}function tuple(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const kinds=schema.map(s=>any(s,void 0,options)),array=scalar(\"array\",void 0,options),type=`[${kinds.map(k=>k.type).join()}]`;return new Kind(\"tuple\",type,(value=resolveDefaults(defaults$$1))=>{const[error]=array.validate(value);if(error){error.type=type;return[error]}const ret=[],errors=[],length=Math.max(value.length,kinds.length);for(let i=0;i<length;i++){const kind=kinds[i],v=value[i];if(!kind){const e={data:value,path:[i],value:v};errors.push(e);continue}const[e,r]=kind.validate(v);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[i].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}ret[i]=r}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})}function union(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const kinds=schema.map(s=>any(s,void 0,options)),type=kinds.map(k=>k.type).join(\" | \");return new Kind(\"union\",type,(value=resolveDefaults(defaults$$1))=>{const errors=[];for(const k of kinds){const[e,r]=k.validate(value);if(!e){return[void 0,r]}errors.push(e)}errors[0].type=type;return errors})}function intersection(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const types=schema.map(s=>any(s,void 0,options)),type=types.map(t=>t.type).join(\" & \");return new Kind(\"intersection\",type,(value=resolveDefaults(defaults$$1))=>{let v=value;for(const t of types){const[e,r]=t.validate(v);if(e){e.type=type;return[e]}v=r}return[void 0,v]})}const Kinds={any,dict:function(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)||2!==schema.length){throw new Error(`Invalid schema: ${schema}`)}const obj=scalar(\"object\",void 0,options),keys=any(schema[0],void 0,options),values=any(schema[1],void 0,options),type=`dict<${keys.type},${values.type}>`;return new Kind(\"dict\",type,value=>{const resolved=resolveDefaults(defaults$$1);value=resolved?_extends({},resolved,value):value;const[error]=obj.validate(value);if(error){error.type=type;return[error]}const ret={},errors=[];for(let k in value){const v=value[k],[e,r]=keys.validate(k);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[k].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}k=r;const[e2,r2]=values.validate(v);if(e2){const allE2=e2.errors||[e2];allE2.forEach(singleE=>{singleE.path=[k].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}ret[k]=r2}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})},enum:en,enums:function(schema,defaults$$1,options){const e=en(schema,void 0,options),l=list([e],defaults$$1,options);return l},function:func,instance:function(schema,defaults$$1){const type=`instance<${schema.name}>`;return new Kind(\"instance\",type,(value=resolveDefaults(defaults$$1))=>{return value instanceof schema?[void 0,value]:[{data:value,path:[],value,type}]})},interface:function(schema,defaults$$1,options){if(\"object\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const ks=[],properties={};for(const key in schema){ks.push(key);const s=schema[key],kind=any(s,void 0,options);properties[key]=kind}const type=`{${ks.join()}}`,validate=value=>{const resolved=resolveDefaults(defaults$$1);value=resolved?_extends({},resolved,value):value;const errors=[],ret=value;for(const key in properties){let v=value[key];const kind=properties[key];if(v===void 0){const d=defaults$$1&&defaults$$1[key];v=resolveDefaults(d,value)}const[e,r]=kind.validate(v,value);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[key].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}if(key in value||r!==void 0){ret[key]=r}}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]};return new Kind(\"interface\",type,validate)},lazy:function(schema){if(\"function\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}let kind,struct;const type=`lazy...`,compile=value=>{struct=schema();kind.name=struct.kind;kind.type=struct.type;kind.validate=struct.validate;return kind.validate(value)};kind=new Kind(\"lazy\",type,compile);return kind},list,literal:function(schema,defaults$$1){const type=`literal: ${JSON.stringify(schema)}`;return new Kind(\"literal\",type,(value=resolveDefaults(defaults$$1))=>{return value===schema?[void 0,value]:[{data:value,path:[],value,type}]})},object,optional,partial:function(schema,defaults$$1,options){if(\"object\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const obj=scalar(\"object\",void 0,options),ks=[],properties={};for(const key in schema){ks.push(key);const s=schema[key],kind=any(s,void 0,options);properties[key]=kind}const type=`{${ks.join()},...}`,validate=(value=resolveDefaults(defaults$$1))=>{const[error]=obj.validate(value);if(error){error.type=type;return[error]}const errors=[],ret={};for(const key in properties){let v=value[key];const kind=properties[key];if(v===void 0){const d=defaults$$1&&defaults$$1[key];v=resolveDefaults(d,value)}const[e,r]=kind.validate(v,value);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[key].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}if(key in value||r!==void 0){ret[key]=r}}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]};return new Kind(\"partial\",type,validate)},scalar,tuple,union,intersection},Types={any:value=>value!==void 0};[\"arguments\",\"array\",\"boolean\",\"buffer\",\"error\",\"float32array\",\"float64array\",\"function\",\"generatorfunction\",\"int16array\",\"int32array\",\"int8array\",\"map\",\"null\",\"number\",\"object\",\"promise\",\"regexp\",\"set\",\"string\",\"symbol\",\"uint16array\",\"uint32array\",\"uint8array\",\"uint8clampedarray\",\"undefined\",\"weakmap\",\"weakset\"].forEach(type=>{Types[type]=value=>kindOf(value)===type});Types.date=value=>\"date\"===kindOf(value)&&!isNaN(value);function superstruct(config={}){const types=_extends({},Types,config.types||{});function struct(schema,defaults$$1,options={}){if(isStruct(schema)){schema=schema.schema}const kind=Kinds.any(schema,defaults$$1,_extends({},options,{types}));function Struct(data){if(this instanceof Struct){throw new Error(\"Invalid `new` keyword!\")}return Struct.assert(data)}Object.defineProperty(Struct,IS_STRUCT,{value:!0});Object.defineProperty(Struct,KIND,{value:kind});Struct.kind=kind.name;Struct.type=kind.type;Struct.schema=schema;Struct.defaults=defaults$$1;Struct.options=options;Struct.assert=value=>{const[error,result]=kind.validate(value);if(error){throw new StructError(error)}return result};Struct.test=value=>{const[error]=kind.validate(value);return!error};Struct.validate=value=>{const[error,result]=kind.validate(value);if(error){return[new StructError(error)]}return[void 0,result]};return Struct}Object.keys(Kinds).forEach(name=>{const kind=Kinds[name];struct[name]=(schema,defaults$$1,options)=>{const type=kind(schema,defaults$$1,_extends({},options,{types})),s=struct(type,defaults$$1,options);return s}});return struct}superstruct()},184:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var polymer_legacy=__webpack_require__(3),iron_flex_layout=__webpack_require__(36),iron_control_state=__webpack_require__(20),iron_validatable_behavior=__webpack_require__(55),polymer_fn=__webpack_require__(4),polymer_dom=__webpack_require__(0),html_tag=__webpack_require__(1);/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/Object(polymer_fn.a)({_template:html_tag.a`\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        width: 400px;\n        border: 1px solid;\n        padding: 2px;\n        -moz-appearance: textarea;\n        -webkit-appearance: textarea;\n        overflow: hidden;\n      }\n\n      .mirror-text {\n        visibility: hidden;\n        word-wrap: break-word;\n        @apply --iron-autogrow-textarea;\n      }\n\n      .fit {\n        @apply --layout-fit;\n      }\n\n      textarea {\n        position: relative;\n        outline: none;\n        border: none;\n        resize: none;\n        background: inherit;\n        color: inherit;\n        /* see comments in template */\n        width: 100%;\n        height: 100%;\n        font-size: inherit;\n        font-family: inherit;\n        line-height: inherit;\n        text-align: inherit;\n        @apply --iron-autogrow-textarea;\n      }\n\n      textarea::-webkit-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea::-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-ms-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n    </style>\n\n    <!-- the mirror sizes the input/textarea so it grows with typing -->\n    <!-- use &#160; instead &nbsp; of to allow this element to be used in XHTML -->\n    <div id=\"mirror\" class=\"mirror-text\" aria-hidden=\"true\">&nbsp;</div>\n\n    <!-- size the input/textarea with a div, because the textarea has intrinsic size in ff -->\n    <div class=\"textarea-container fit\">\n      <textarea id=\"textarea\" name\\$=\"[[name]]\" aria-label\\$=\"[[label]]\" autocomplete\\$=\"[[autocomplete]]\" autofocus\\$=\"[[autofocus]]\" inputmode\\$=\"[[inputmode]]\" placeholder\\$=\"[[placeholder]]\" readonly\\$=\"[[readonly]]\" required\\$=\"[[required]]\" disabled\\$=\"[[disabled]]\" rows\\$=\"[[rows]]\" minlength\\$=\"[[minlength]]\" maxlength\\$=\"[[maxlength]]\"></textarea>\n    </div>\n`,is:\"iron-autogrow-textarea\",behaviors:[iron_validatable_behavior.a,iron_control_state.a],properties:{value:{observer:\"_valueChanged\",type:String,notify:!0},bindValue:{observer:\"_bindValueChanged\",type:String,notify:!0},rows:{type:Number,value:1,observer:\"_updateCached\"},maxRows:{type:Number,value:0,observer:\"_updateCached\"},autocomplete:{type:String,value:\"off\"},autofocus:{type:Boolean,value:!1},inputmode:{type:String},placeholder:{type:String},readonly:{type:String},required:{type:Boolean},minlength:{type:Number},maxlength:{type:Number},label:{type:String}},listeners:{input:\"_onInput\"},get textarea(){return this.$.textarea},get selectionStart(){return this.$.textarea.selectionStart},get selectionEnd(){return this.$.textarea.selectionEnd},set selectionStart(value){this.$.textarea.selectionStart=value},set selectionEnd(value){this.$.textarea.selectionEnd=value},attached:function(){var IS_IOS=navigator.userAgent.match(/iP(?:[oa]d|hone)/);if(IS_IOS){this.$.textarea.style.marginLeft=\"-3px\"}},validate:function(){var valid=this.$.textarea.validity.valid;if(valid){if(this.required&&\"\"===this.value){valid=!1}else if(this.hasValidator()){valid=iron_validatable_behavior.a.validate.call(this,this.value)}}this.invalid=!valid;this.fire(\"iron-input-validate\");return valid},_bindValueChanged:function(bindValue){this.value=bindValue},_valueChanged:function(value){var textarea=this.textarea;if(!textarea){return}if(textarea.value!==value){textarea.value=!(value||0===value)?\"\":value}this.bindValue=value;this.$.mirror.innerHTML=this._valueForMirror();this.fire(\"bind-value-changed\",{value:this.bindValue})},_onInput:function(event){var eventPath=Object(polymer_dom.b)(event).path;this.value=eventPath?eventPath[0].value:event.target.value},_constrain:function(tokens){var _tokens;tokens=tokens||[\"\"];if(0<this.maxRows&&tokens.length>this.maxRows){_tokens=tokens.slice(0,this.maxRows)}else{_tokens=tokens.slice(0)}while(0<this.rows&&_tokens.length<this.rows){_tokens.push(\"\")}return _tokens.join(\"<br/>\")+\"&#160;\"},_valueForMirror:function(){var input=this.textarea;if(!input){return}this.tokens=input&&input.value?input.value.replace(/&/gm,\"&amp;\").replace(/\"/gm,\"&quot;\").replace(/'/gm,\"&#39;\").replace(/</gm,\"&lt;\").replace(/>/gm,\"&gt;\").split(\"\\n\"):[\"\"];return this._constrain(this.tokens)},_updateCached:function(){this.$.mirror.innerHTML=this._constrain(this.tokens)}});var paper_input_char_counter=__webpack_require__(103),paper_input_container=__webpack_require__(104),paper_input_error=__webpack_require__(105),iron_form_element_behavior=__webpack_require__(54),paper_input_behavior=__webpack_require__(84);/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/Object(polymer_fn.a)({_template:html_tag.a`\n    <style>\n      :host {\n        display: block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      label {\n        pointer-events: none;\n      }\n    </style>\n\n    <paper-input-container no-label-float\\$=\"[[noLabelFloat]]\" always-float-label=\"[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]\" auto-validate\\$=\"[[autoValidate]]\" disabled\\$=\"[[disabled]]\" invalid=\"[[invalid]]\">\n\n      <label hidden\\$=\"[[!label]]\" aria-hidden=\"true\" for\\$=\"[[_inputId]]\" slot=\"label\">[[label]]</label>\n\n      <iron-autogrow-textarea class=\"paper-input-input\" slot=\"input\" id\\$=\"[[_inputId]]\" aria-labelledby\\$=\"[[_ariaLabelledBy]]\" aria-describedby\\$=\"[[_ariaDescribedBy]]\" bind-value=\"{{value}}\" invalid=\"{{invalid}}\" validator\\$=\"[[validator]]\" disabled\\$=\"[[disabled]]\" autocomplete\\$=\"[[autocomplete]]\" autofocus\\$=\"[[autofocus]]\" inputmode\\$=\"[[inputmode]]\" name\\$=\"[[name]]\" placeholder\\$=\"[[placeholder]]\" readonly\\$=\"[[readonly]]\" required\\$=\"[[required]]\" minlength\\$=\"[[minlength]]\" maxlength\\$=\"[[maxlength]]\" autocapitalize\\$=\"[[autocapitalize]]\" rows\\$=\"[[rows]]\" max-rows\\$=\"[[maxRows]]\" on-change=\"_onChange\"></iron-autogrow-textarea>\n\n      <template is=\"dom-if\" if=\"[[errorMessage]]\">\n        <paper-input-error aria-live=\"assertive\" slot=\"add-on\">[[errorMessage]]</paper-input-error>\n      </template>\n\n      <template is=\"dom-if\" if=\"[[charCounter]]\">\n        <paper-input-char-counter slot=\"add-on\"></paper-input-char-counter>\n      </template>\n\n    </paper-input-container>\n`,is:\"paper-textarea\",behaviors:[paper_input_behavior.a,iron_form_element_behavior.a],properties:{_ariaLabelledBy:{observer:\"_ariaLabelledByChanged\",type:String},_ariaDescribedBy:{observer:\"_ariaDescribedByChanged\",type:String},value:{type:String},rows:{type:Number,value:1},maxRows:{type:Number,value:0}},get selectionStart(){return this.$.input.textarea.selectionStart},set selectionStart(start){this.$.input.textarea.selectionStart=start},get selectionEnd(){return this.$.input.textarea.selectionEnd},set selectionEnd(end){this.$.input.textarea.selectionEnd=end},_ariaLabelledByChanged:function(ariaLabelledBy){this._focusableElement.setAttribute(\"aria-labelledby\",ariaLabelledBy)},_ariaDescribedByChanged:function(ariaDescribedBy){this._focusableElement.setAttribute(\"aria-describedby\",ariaDescribedBy)},get _focusableElement(){return this.inputElement.textarea}})}}]);"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourceRoot":""}