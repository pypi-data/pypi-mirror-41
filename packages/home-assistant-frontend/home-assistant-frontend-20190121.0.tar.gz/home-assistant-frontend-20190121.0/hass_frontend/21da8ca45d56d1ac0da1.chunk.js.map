{"version":3,"file":"21da8ca45d56d1ac0da1.chunk.js","sources":["webpack:///21da8ca45d56d1ac0da1.chunk.js"],"sourcesContent":["(window.webpackJsonp=window.webpackJsonp||[]).push([[114,107,108,109,110,111,112,113,115,116,117],{155:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(3),_polymer_iron_flex_layout_iron_flex_layout_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(37),_polymer_paper_styles_default_theme_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(41),_polymer_paper_styles_typography_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(52),_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(4),_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(1);/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/Object(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_4__.a)({_template:_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_5__.a`\n    <style>\n      :host {\n        overflow: hidden; /* needed for text-overflow: ellipsis to work on ff */\n        @apply --layout-vertical;\n        @apply --layout-center-justified;\n        @apply --layout-flex;\n      }\n\n      :host([two-line]) {\n        min-height: var(--paper-item-body-two-line-min-height, 72px);\n      }\n\n      :host([three-line]) {\n        min-height: var(--paper-item-body-three-line-min-height, 88px);\n      }\n\n      :host > ::slotted(*) {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n      }\n\n      :host > ::slotted([secondary]) {\n        @apply --paper-font-body1;\n\n        color: var(--paper-item-body-secondary-color, var(--secondary-text-color));\n\n        @apply --paper-item-body-secondary;\n      }\n    </style>\n\n    <slot></slot>\n`,is:\"paper-item-body\"})},162:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(3),_polymer_iron_flex_layout_iron_flex_layout_js__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(37),_polymer_paper_styles_typography_js__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(52),_paper_item_shared_styles_js__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(126),_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(4),_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(1),_paper_item_behavior_js__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(106);/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/Object(_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_4__.a)({_template:_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_5__.a`\n    <style include=\"paper-item-shared-styles\"></style>\n    <style>\n      :host {\n        @apply --layout-horizontal;\n        @apply --layout-center;\n        @apply --paper-font-subhead;\n\n        @apply --paper-item;\n        @apply --paper-icon-item;\n      }\n\n      .content-icon {\n        @apply --layout-horizontal;\n        @apply --layout-center;\n\n        width: var(--paper-item-icon-width, 56px);\n        @apply --paper-item-icon;\n      }\n    </style>\n\n    <div id=\"contentIcon\" class=\"content-icon\">\n      <slot name=\"item-icon\"></slot>\n    </div>\n    <slot></slot>\n`,is:\"paper-icon-item\",behaviors:[_paper_item_behavior_js__WEBPACK_IMPORTED_MODULE_6__.a]})},169:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return superstruct});class StructError extends TypeError{static format(attrs){const{type,path,value}=attrs,message=`Expected a value of type \\`${type}\\`${path.length?` for \\`${path.join(\".\")}\\``:\"\"} but received \\`${JSON.stringify(value)}\\`.`;return message}constructor(attrs){const message=StructError.format(attrs);super(message);const{data,path,value,reason,type,errors=[]}=attrs;this.data=data;this.path=path;this.value=value;this.reason=reason;this.type=type;this.errors=errors;if(!errors.length){errors.push(this)}if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}else{this.stack=new Error().stack}}}var toString=Object.prototype.toString,kindOf=function(val){if(void 0===val)return\"undefined\";if(null===val)return\"null\";var type=typeof val;if(\"boolean\"===type)return\"boolean\";if(\"string\"===type)return\"string\";if(\"number\"===type)return\"number\";if(\"symbol\"===type)return\"symbol\";if(\"function\"===type){return isGeneratorFn(val)?\"generatorfunction\":\"function\"}if(isArray(val))return\"array\";if(isBuffer(val))return\"buffer\";if(isArguments(val))return\"arguments\";if(isDate(val))return\"date\";if(isError(val))return\"error\";if(isRegexp(val))return\"regexp\";switch(ctorName(val)){case\"Symbol\":return\"symbol\";case\"Promise\":return\"promise\";case\"WeakMap\":return\"weakmap\";case\"WeakSet\":return\"weakset\";case\"Map\":return\"map\";case\"Set\":return\"set\";case\"Int8Array\":return\"int8array\";case\"Uint8Array\":return\"uint8array\";case\"Uint8ClampedArray\":return\"uint8clampedarray\";case\"Int16Array\":return\"int16array\";case\"Uint16Array\":return\"uint16array\";case\"Int32Array\":return\"int32array\";case\"Uint32Array\":return\"uint32array\";case\"Float32Array\":return\"float32array\";case\"Float64Array\":return\"float64array\";}if(isGeneratorObj(val)){return\"generator\"}type=toString.call(val);switch(type){case\"[object Object]\":return\"object\";case\"[object Map Iterator]\":return\"mapiterator\";case\"[object Set Iterator]\":return\"setiterator\";case\"[object String Iterator]\":return\"stringiterator\";case\"[object Array Iterator]\":return\"arrayiterator\";}return type.slice(8,-1).toLowerCase().replace(/\\s/g,\"\")};function ctorName(val){return val.constructor?val.constructor.name:null}function isArray(val){if(Array.isArray)return Array.isArray(val);return val instanceof Array}function isError(val){return val instanceof Error||\"string\"===typeof val.message&&val.constructor&&\"number\"===typeof val.constructor.stackTraceLimit}function isDate(val){if(val instanceof Date)return!0;return\"function\"===typeof val.toDateString&&\"function\"===typeof val.getDate&&\"function\"===typeof val.setDate}function isRegexp(val){if(val instanceof RegExp)return!0;return\"string\"===typeof val.flags&&\"boolean\"===typeof val.ignoreCase&&\"boolean\"===typeof val.multiline&&\"boolean\"===typeof val.global}function isGeneratorFn(name){return\"GeneratorFunction\"===ctorName(name)}function isGeneratorObj(val){return\"function\"===typeof val.throw&&\"function\"===typeof val.return&&\"function\"===typeof val.next}function isArguments(val){try{if(\"number\"===typeof val.length&&\"function\"===typeof val.callee){return!0}}catch(err){if(-1!==err.message.indexOf(\"callee\")){return!0}}return!1}function isBuffer(val){if(val.constructor&&\"function\"===typeof val.constructor.isBuffer){return val.constructor.isBuffer(val)}return!1}const IS_STRUCT=\"@@__STRUCT__@@\",KIND=\"@@__KIND__@@\";function isStruct(value){return!!(value&&value[IS_STRUCT])}function resolveDefaults(defaults,value){return\"function\"===typeof defaults?defaults(value):defaults}var _extends=Object.assign||function(target){for(var i=1,source;i<arguments.length;i++){source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key]}}}return target};class Kind{constructor(name,type,validate){this.name=name;this.type=type;this.validate=validate}}function any(schema,defaults$$1,options){if(isStruct(schema)){return schema[KIND]}if(schema instanceof Kind){return schema}switch(kindOf(schema)){case\"array\":{return 1<schema.length?tuple(schema,defaults$$1,options):list(schema,defaults$$1,options)}case\"function\":{return func(schema,defaults$$1,options)}case\"object\":{return object(schema,defaults$$1,options)}case\"string\":{let required=!0,type;if(schema.endsWith(\"?\")){required=!1;schema=schema.slice(0,-1)}if(schema.includes(\"|\")){const scalars=schema.split(/\\s*\\|\\s*/g);type=union(scalars,defaults$$1,options)}else if(schema.includes(\"&\")){const scalars=schema.split(/\\s*&\\s*/g);type=intersection(scalars,defaults$$1,options)}else{type=scalar(schema,defaults$$1,options)}if(!required){type=optional(type,void 0,options)}return type}}throw new Error(`Invalid schema: ${schema}`)}function en(schema,defaults$$1){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const type=schema.map(s=>{try{return JSON.stringify(s)}catch(e){return s+\"\"}}).join(\" | \");return new Kind(\"enum\",type,(value=resolveDefaults(defaults$$1))=>{return schema.includes(value)?[void 0,value]:[{data:value,path:[],value,type}]})}function func(schema,defaults$$1){if(\"function\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const type=\"<function>\";return new Kind(\"function\",type,(value=resolveDefaults(defaults$$1),data)=>{const result=schema(value,data);let failure={path:[],reason:null},isValid;switch(kindOf(result)){case\"boolean\":{isValid=result;break}case\"string\":{isValid=!1;failure.reason=result;break}case\"object\":{isValid=!1;failure=_extends({},failure,result);break}default:{throw new Error(`Invalid result: ${result}`)}}return isValid?[void 0,value]:[_extends({type,value,data:value},failure)]})}function list(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)||1!==schema.length){throw new Error(`Invalid schema: ${schema}`)}const array=scalar(\"array\",void 0,options),element=any(schema[0],void 0,options),type=`[${element.type}]`;return new Kind(\"list\",type,(value=resolveDefaults(defaults$$1))=>{const[error,result]=array.validate(value);if(error){error.type=type;return[error]}value=result;const errors=[],ret=[];for(let i=0;i<value.length;i++){const v=value[i],[e,r]=element.validate(v);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[i].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}ret[i]=r}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})}function object(schema,defaults$$1,options){if(\"object\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const obj=scalar(\"object\",void 0,options),ks=[],properties={};for(const key in schema){ks.push(key);const s=schema[key],kind=any(s,void 0,options);properties[key]=kind}const type=`{${ks.join()}}`;return new Kind(\"object\",type,(value=resolveDefaults(defaults$$1))=>{const[error]=obj.validate(value);if(error){error.type=type;return[error]}const errors=[],ret={},valueKeys=Object.keys(value),propertiesKeys=Object.keys(properties),keys=new Set(valueKeys.concat(propertiesKeys));keys.forEach(key=>{let v=value[key];const kind=properties[key];if(v===void 0){const d=defaults$$1&&defaults$$1[key];v=resolveDefaults(d,value)}if(!kind){const e={data:value,path:[key],value:v};errors.push(e);return}const[e,r]=kind.validate(v,value);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[key].concat(singleE.path);singleE.data=value;errors.push(singleE)});return}if(key in value||r!==void 0){ret[key]=r}});if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})}function optional(schema,defaults$$1,options){return union([schema,\"undefined\"],defaults$$1,options)}function scalar(schema,defaults$$1,options){if(\"string\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const{types}=options,fn=types[schema];if(\"function\"!==kindOf(fn)){throw new Error(`Invalid type: ${schema}`)}const kind=func(fn,defaults$$1,options),type=schema;return new Kind(\"scalar\",type,value=>{const[error,result]=kind.validate(value);if(error){error.type=type;return[error]}return[void 0,result]})}function tuple(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const kinds=schema.map(s=>any(s,void 0,options)),array=scalar(\"array\",void 0,options),type=`[${kinds.map(k=>k.type).join()}]`;return new Kind(\"tuple\",type,(value=resolveDefaults(defaults$$1))=>{const[error]=array.validate(value);if(error){error.type=type;return[error]}const ret=[],errors=[],length=Math.max(value.length,kinds.length);for(let i=0;i<length;i++){const kind=kinds[i],v=value[i];if(!kind){const e={data:value,path:[i],value:v};errors.push(e);continue}const[e,r]=kind.validate(v);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[i].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}ret[i]=r}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})}function union(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const kinds=schema.map(s=>any(s,void 0,options)),type=kinds.map(k=>k.type).join(\" | \");return new Kind(\"union\",type,(value=resolveDefaults(defaults$$1))=>{const errors=[];for(const k of kinds){const[e,r]=k.validate(value);if(!e){return[void 0,r]}errors.push(e)}errors[0].type=type;return errors})}function intersection(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const types=schema.map(s=>any(s,void 0,options)),type=types.map(t=>t.type).join(\" & \");return new Kind(\"intersection\",type,(value=resolveDefaults(defaults$$1))=>{let v=value;for(const t of types){const[e,r]=t.validate(v);if(e){e.type=type;return[e]}v=r}return[void 0,v]})}const Kinds={any,dict:function(schema,defaults$$1,options){if(\"array\"!==kindOf(schema)||2!==schema.length){throw new Error(`Invalid schema: ${schema}`)}const obj=scalar(\"object\",void 0,options),keys=any(schema[0],void 0,options),values=any(schema[1],void 0,options),type=`dict<${keys.type},${values.type}>`;return new Kind(\"dict\",type,value=>{const resolved=resolveDefaults(defaults$$1);value=resolved?_extends({},resolved,value):value;const[error]=obj.validate(value);if(error){error.type=type;return[error]}const ret={},errors=[];for(let k in value){const v=value[k],[e,r]=keys.validate(k);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[k].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}k=r;const[e2,r2]=values.validate(v);if(e2){const allE2=e2.errors||[e2];allE2.forEach(singleE=>{singleE.path=[k].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}ret[k]=r2}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]})},enum:en,enums:function(schema,defaults$$1,options){const e=en(schema,void 0,options),l=list([e],defaults$$1,options);return l},function:func,instance:function(schema,defaults$$1){const type=`instance<${schema.name}>`;return new Kind(\"instance\",type,(value=resolveDefaults(defaults$$1))=>{return value instanceof schema?[void 0,value]:[{data:value,path:[],value,type}]})},interface:function(schema,defaults$$1,options){if(\"object\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const ks=[],properties={};for(const key in schema){ks.push(key);const s=schema[key],kind=any(s,void 0,options);properties[key]=kind}const type=`{${ks.join()}}`,validate=value=>{const resolved=resolveDefaults(defaults$$1);value=resolved?_extends({},resolved,value):value;const errors=[],ret=value;for(const key in properties){let v=value[key];const kind=properties[key];if(v===void 0){const d=defaults$$1&&defaults$$1[key];v=resolveDefaults(d,value)}const[e,r]=kind.validate(v,value);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[key].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}if(key in value||r!==void 0){ret[key]=r}}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]};return new Kind(\"interface\",type,validate)},lazy:function(schema){if(\"function\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}let kind,struct;const type=`lazy...`,compile=value=>{struct=schema();kind.name=struct.kind;kind.type=struct.type;kind.validate=struct.validate;return kind.validate(value)};kind=new Kind(\"lazy\",type,compile);return kind},list,literal:function(schema,defaults$$1){const type=`literal: ${JSON.stringify(schema)}`;return new Kind(\"literal\",type,(value=resolveDefaults(defaults$$1))=>{return value===schema?[void 0,value]:[{data:value,path:[],value,type}]})},object,optional,partial:function(schema,defaults$$1,options){if(\"object\"!==kindOf(schema)){throw new Error(`Invalid schema: ${schema}`)}const obj=scalar(\"object\",void 0,options),ks=[],properties={};for(const key in schema){ks.push(key);const s=schema[key],kind=any(s,void 0,options);properties[key]=kind}const type=`{${ks.join()},...}`,validate=(value=resolveDefaults(defaults$$1))=>{const[error]=obj.validate(value);if(error){error.type=type;return[error]}const errors=[],ret={};for(const key in properties){let v=value[key];const kind=properties[key];if(v===void 0){const d=defaults$$1&&defaults$$1[key];v=resolveDefaults(d,value)}const[e,r]=kind.validate(v,value);if(e){const allE=e.errors||[e];allE.forEach(singleE=>{singleE.path=[key].concat(singleE.path);singleE.data=value;errors.push(singleE)});continue}if(key in value||r!==void 0){ret[key]=r}}if(errors.length){const first=errors[0];first.errors=errors;return[first]}return[void 0,ret]};return new Kind(\"partial\",type,validate)},scalar,tuple,union,intersection},Types={any:value=>value!==void 0};[\"arguments\",\"array\",\"boolean\",\"buffer\",\"error\",\"float32array\",\"float64array\",\"function\",\"generatorfunction\",\"int16array\",\"int32array\",\"int8array\",\"map\",\"null\",\"number\",\"object\",\"promise\",\"regexp\",\"set\",\"string\",\"symbol\",\"uint16array\",\"uint32array\",\"uint8array\",\"uint8clampedarray\",\"undefined\",\"weakmap\",\"weakset\"].forEach(type=>{Types[type]=value=>kindOf(value)===type});Types.date=value=>\"date\"===kindOf(value)&&!isNaN(value);function superstruct(config={}){const types=_extends({},Types,config.types||{});function struct(schema,defaults$$1,options={}){if(isStruct(schema)){schema=schema.schema}const kind=Kinds.any(schema,defaults$$1,_extends({},options,{types}));function Struct(data){if(this instanceof Struct){throw new Error(\"Invalid `new` keyword!\")}return Struct.assert(data)}Object.defineProperty(Struct,IS_STRUCT,{value:!0});Object.defineProperty(Struct,KIND,{value:kind});Struct.kind=kind.name;Struct.type=kind.type;Struct.schema=schema;Struct.defaults=defaults$$1;Struct.options=options;Struct.assert=value=>{const[error,result]=kind.validate(value);if(error){throw new StructError(error)}return result};Struct.test=value=>{const[error]=kind.validate(value);return!error};Struct.validate=value=>{const[error,result]=kind.validate(value);if(error){return[new StructError(error)]}return[void 0,result]};return Struct}Object.keys(Kinds).forEach(name=>{const kind=Kinds[name];struct[name]=(schema,defaults$$1,options)=>{const type=kind(schema,defaults$$1,_extends({},options,{types})),s=struct(type,defaults$$1,options);return s}});return struct}superstruct()}}]);"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourceRoot":""}