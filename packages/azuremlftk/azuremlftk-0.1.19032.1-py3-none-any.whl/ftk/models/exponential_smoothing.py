from itertools import product
from warnings import warn
import numpy as np
import pandas as pd
from statsmodels.tsa.holtwinters import ExponentialSmoothing as ETS_sm

from ftk.models.recursive_forecaster import RecursiveForecaster

def _complete_short_series(series_values, season_len):
    """
    statsmodels requires at least two full seasons of data
    in order to train. "Complete" the data if this requirement
    is not met.
    If there is less than one full season, carry the last observation
    forward to complete a full season.
    Use a seasonal naive imputation to fill in series values
    so the completed series has length at least 2*season_len

    """
    series_len = len(series_values)

    # Nothing to do if we already have at least two seasons of data
    if series_len >= 2*season_len:
        return series_values

    if series_len < season_len:
        last_obs = series_values[-1]
        one_season_ext = np.repeat(last_obs, season_len - series_len)
    else:
        one_season_ext = np.array([])

    # Complete a full season
    series_values_ext = np.append(series_values, one_season_ext)

    # Complete the second season via seasonal naive imputation
    num_past_season = len(series_values_ext) - season_len
    series_first_season = series_values_ext[:season_len]
    series_snaive_second_season = series_first_season[num_past_season:]

    # Get the final bit of the series by seasonal naive imputation
    series_snaive_end = series_values_ext[season_len:]

    # Concatenate all the imputations and return
    return np.concatenate((series_values_ext,
                           series_snaive_second_season,
                           series_snaive_end))

def _sm_is_ver9():
    """
    Try to determine if the statsmodels version is 0.9.x.
    """
    try:
        import pkg_resources
        sm_ver = pkg_resources.get_distribution('statsmodels').version
        major, minor = sm_ver.split('.')[:2]
        if major == '0' and minor == '9':
            return True
    except:
        return True

    return False

def _extend_series_for_sm9_bug(series_values, season_len, model_type):
    """
    statsmodel 0.9.0 has a bug that causes division by zero during
    model fitting under the following condition:
    series_length = num_model_params + 3.

    Try to detect this condition and if it is found, carry the last
    observation forward once in order to increase the series length.

    This bug is fixed in the (dev) version 0.10.x. 
    """
    trend_type, seas_type, damped = model_type
    num_params = 2 + 2 * (trend_type != 'N') + 1 * (damped) + \
        season_len * (seas_type != 'N')

    if len(series_values) == num_params + 3:
        series_ext = np.append(series_values, series_values[-1])
    else:
        series_ext = series_values

    return series_ext


class ExponentialSmoothing(RecursiveForecaster):
    """
    Adaptation of statsmodels Holt-Winters/Exponential Smoothing univariate 
    time series model to the FTK framework.
    See the statsmodel documentation:
     https://www.statsmodels.org/stable/generated/statsmodels.tsa.holtwinters.ExponentialSmoothing.html#statsmodels.tsa.holtwinters.ExponentialSmoothing

    This class primarily implements the abstract methods in RecursiveForecaster
    for training/forecasting single series.

    Holt-Winters/Exponential Smoothing is really a class of related models.
    The user must either explicitly set the trend, seasonality, and damping
    model types or allow the 'fit' method to select the best model via a
    penalized likelihood metric. See the `model_type`, `damped`, and
    `selection_metric` parameter docstrings for more information.

    The statsmodels parameter estimation code requires that every time-series
    have at least two full seasons of data. In case this requirement is not met,
    the 'fit' method will "complete" the series to meet the requirement.
    "Short" series fall into the following two cases:
    * len(series) <= season_length
      In this case, a full season will be generated by carrying the last
      observation forward (if necessary). 
      The full season will then be repeated to give a series with
      two full seasons.
      Example: series = [y1, y2], season_length = 4.
      series_completed = [y1, y2, y2, y2, y1, y2, y2, y2]
    * season_length < len(series) < 2*season_length
      Here, a seasonal-naive imputation is used to complete the series
      in a phase consistent manner.
      Example: series = [y1, y2, y3, y4, y5], season_length = 3.
      series_completed = [y1, y2, y3, y4, y5, y3, y4, y5]

    :param model_type:
        Type of Exponential Smoothing model to use.
        Value must be a two character string. The first character is the type
        of trend model, the second is the type of seasonal model.
        Choices for both are:
        * 'A' - additive model
        * 'M' - multiplicative model
        * 'N' - None. Don't use this term in the model at all
        * 'Z' - Automatically select this type using the selection metric
        Example: model_type='AZ'. Use a model with additive trend model
        and automatically select the seasonal model type.
    :type model_type: str

    :param damped:
        Whether to use a damping term in the trend model.
        Choices are:
        * True - Use a damping term in the trend model
        * False - Do not model trend damping
        * None - Automatically select this setting using the selection metric
    :type damped: bool

    :param selection_metric:
        Metric to use for automatic selection of model type.
        Choices are:
        * 'aic' - Akaike Information Criterion
        * 'aicc' - AIC with a small sample size correction
        * 'bic' - Bayesian Information Criterion
    :type selection_metric: str

    :param allow_multiplicative_trend:
        Whether to allow models with a multiplicative type trend.
        These kinds of models can be unstable, so they may be black-listed
        for safer operation.
    :type allow_multiplicative_trend: bool

    :param use_boxcox:
        From statsmodels help:
        Should the boxcox tranform be applied to the data first?
        If ‘log’ then apply the log. If float then use lambda equal to float.
    :type use_boxcox: bool, str, float

    :param use_basinhopping:
        From statsmodels help:
        Should the opptimser try harder using basinhopping
        to find optimal values?
    :type use_basinhopping: bool

    For a description of the other parameters,
    see :class:`ftk.models.recursive_forecaster.RecursiveForecaster`

    """

    _sm9_bug_workaround = _sm_is_ver9()

    def __init__(self, model_type='ZZ',
                 damped=False, selection_metric='aic',
                 allow_multiplicative_trend=True,
                 use_boxcox=False, use_basinhopping=False,
                 freq=None, seasonality=None,
                 pred_point_colname=None, pred_dist_colname=None,
                 origin_time_colname=None):

        # Must call the RecursiveForecaster constructor first!
        super().__init__(freq=freq, seasonality=seasonality,
                         pred_point_colname=pred_point_colname,
                         pred_dist_colname=pred_dist_colname,
                         origin_time_colname=origin_time_colname)

        self.model_type = model_type
        self.damped = damped
        self.selection_metric = selection_metric
        self.allow_multiplicative_trend = allow_multiplicative_trend
        self.use_boxcox = use_boxcox
        self.use_basinhopping = use_basinhopping

        self._char_to_statsmodels_opt = \
            {'A': 'add', 'M': 'mul', 'N': None}

    @property
    def model_type(self):
        """
        Type of model to use. See `model_type` param docstring.
        """
        return self._model_type

    @model_type.setter
    def model_type(self, val):
        err_msg = 'Invalid input {0}. \
        `model_type` must a two character string \
        where the first character indicates trend type and the second \
        indicates seasonality type. Options are A (additive), \
        M (multiplicative), N (None), and Z (automatic selection).'.format(val)

        opts = ['A', 'M', 'N', 'Z']

        if not isinstance(val, str):
            raise TypeError(err_msg)

        if len(val) != 2:
            raise ValueError(err_msg)

        if (val[0] not in opts) or (val[1] not in opts):
            raise ValueError(err_msg)

        self._model_type = val

    @property
    def selection_metric(self):
        """
        Metric to use for automatic model selection.
        See `selection_metric` param docstring
        """
        return self._selection_metric

    @selection_metric.setter
    def selection_metric(self, val):
        opts = ['aic', 'bic', 'aicc']
        err_msg = "Invalid input {0}. \
        `selection_metric` must be one of {1}".format(val, opts)

        if not isinstance(val, str):
            raise TypeError(err_msg)

        if val not in opts:
            raise ValueError(err_msg)

        self._selection_metric = val

    @property
    def fit_model_types(self):
        """
        Dictionary of model types for all fitted models.
        Dict keys are grain levels from the training data.
        Dict values are tuples with three entries:
        (trend_type, seasonal_type, with_damping)
        
        Example:
        Suppose a model is fit on a single series associated with
        grain, 'tropicana'.
        fit_model_types may return {'tropicana': ('A', 'N', False)}.
        This means that the tropicana series was fit with an additive trend
        model with no damping and no seasonal component.
        """
        return {gr: typ for gr, (typ, _) in self._models.items()}

    def _assert_damping_valid(self):
        """
        Make sure the damped setting is consistent with the model type setting
        """
        if self.model_type[0] == 'N' and self.damped:
            raise ValueError(
                ('Inconsistent settings: `model_type`={0} and `damped`={1}. '
                 + 'Damping can only be applied when there is a trend term.')
                .format(self.model_type, self.damped))

    def _assert_mult_model_valid(self, series_values):
        """
        Make sure that multiplicative model settings are consistent with
        other settings and with the numerical values of the series.
        Currently, the underlying fit cannot handle zero or negative valued
        series with multiplicative models.
        """
        if not self.allow_multiplicative_trend and self.model_type[0] == 'M':
            raise ValueError(
                ('Inconsistent settings: `allow_multiplicative_trend`=False '
                 + 'and `model_type`={0}.').format(self.model_type))

        if 'M' in self.model_type and (series_values <= 0.0).any():
            raise ValueError(
                ('Cannot use multiplicative model type {0} because series '
                 + 'contains negative or zero values.')
                .format(self.model_type))

    def _make_param_grid(self, is_seasonal):
        """
        Make an iterable of model type triples (trend, seasonal, damping)
        to fit for model selection
        """
        trend_in, seas_in = self.model_type
        trend_grid = [trend_in] if trend_in != 'Z' else ['A', 'M', 'N']

        if is_seasonal:
            seasonal_grid = [seas_in] if seas_in != 'Z' else ['A', 'M', 'N']
        else:
            seasonal_grid = ['N']

        damped_grid = [self.damped] \
            if self.damped is not None else [True, False]

        return product(trend_grid, seasonal_grid, damped_grid)

    def _single_series_train(self, series_values, grain_level):

        # Model type consistency checks
        self._assert_damping_valid()
        self._assert_mult_model_valid(series_values)

        # Get the seasonality and store it in the object state
        # The seasonality is either set by the user or automatically detected
        my_seasonality = \
            self._single_series_get_seasonality(series_values, grain_level)
        self._seasonality_output[grain_level] = my_seasonality

        # Make sure the series is long enough for fitting
        # If not, impute values to "complete" the series
        series_values = _complete_short_series(series_values, my_seasonality)

        # Set the number of seasonal periods (if seasonal)
        seasonal_periods = my_seasonality if my_seasonality > 1 else None
        
        # Internal function for fitting a statsmodel ETS model
        #  and determining if a model type should be considered in selection
        # ------------------------------------------------------------------
        def fit_sm(model_type):
            trend_type, seas_type, damped = model_type

            if self._sm9_bug_workaround:
                series_values_safe = \
                    _extend_series_for_sm9_bug(series_values, my_seasonality,
                                               model_type)
            else:
                series_values_safe = series_values

            ets_model = \
                ETS_sm(series_values_safe, 
                       trend=self._char_to_statsmodels_opt[trend_type],
                       seasonal=self._char_to_statsmodels_opt[seas_type],
                       damped=damped,
                       seasonal_periods=seasonal_periods)

            return ets_model.fit(use_boxcox=self.use_boxcox,
                                 use_basinhopping=self.use_basinhopping)

        def model_is_valid(model_type, has_zero_or_neg):
            trend_type, seas_type, damped = model_type

            if not self.allow_multiplicative_trend and trend_type == 'M':
                return False

            if trend_type == 'N' and damped:
                return False

            if (trend_type == 'M' or seas_type == 'M') \
                and has_zero_or_neg:
                return False

            return True
        # ------------------------------------------------------------------

        # Make a grid of model types and select the one with minimum loss
        has_zero_or_neg = (series_values <= 0.0).any()
        type_grid = self._make_param_grid(my_seasonality > 1)
        fit_models = {mtype: fit_sm(mtype) for mtype in type_grid
                      if model_is_valid(mtype, has_zero_or_neg)}
        best_type, best_result = \
            min(fit_models.items(),
                key=lambda it: getattr(it[1], self.selection_metric))
        
        return best_type, best_result

    def _single_series_point_forecast(self, model, max_horizon, grain_level):
        _, fit_results = model
        return fit_results.forecast(steps=max_horizon)

    def _single_series_distribution_forecast(self, model, max_horizon,
                                             grain_level):
        # statsmodels doesn't natively compute forecast intervals for ETS
        # It probably does provide the raw ingredients to compute them though
        # For now, just return NAs
        return np.repeat(np.nan, max_horizon)

    def _return_fitted_values(self, model, grain_level):
        _, fit_results = model
        return fit_results.fittedvalues

