"""
Here only models related with Packages.
"""
import logging

import stripe
from adminsortable.models import SortableMixin
from django.conf import settings
from django.contrib.sites.models import Site
from django.db import models
from django.db.models.signals import (post_save, post_delete)
from django.urls import reverse
from stripe.error import InvalidRequestError
from twilio.base.exceptions import TwilioRestException
from twilio.rest import Client as TwilioRestClient

from ccc.packages import cloud_tasks
from ccc.packages.managers import (RechargesPackageManager, SubscriptionsPackageManager)
from ccc.packages.signals import (
    signal_push_package_to_stripe,
    signal_delete_package_in_stripe,
    signal_delete_twilio_number,
)

logger = logging.getLogger(__name__)

# SET the Stripe API Key. Stripe support to use multiple API Keys depending of operation.
stripe.api_key = settings.STRIPE_SECRET_KEY


class PackageType(SortableMixin):
    """All the Packages/Plans offered by the application.
    Plans define the base price, currency, and billing cycle for subscriptions.
    For example, you might have a $5/month plan that provides limited access to your products,
    and a $15/month plan that allows full access.
    """
    RECHARGE = '1'
    SUBSCRIPTION = '2'
    PACKAGE_TYPE = ((RECHARGE, 'Recharge'), (SUBSCRIPTION, 'Registration'))

    DEFAULT_BILLING_FREQUENCY = 'month'  # https://stripe.com/docs/api/plans/create?lang=python#create_plan-interval
    DEFAULT_CURRENCY = "usd"  # https://stripe.com/docs/api/refunds/object#refund_object-currency

    title = models.CharField(max_length=255, help_text='Package name.')
    sku = models.SlugField(max_length=255, help_text='Stripe plan ID. this is autogenerated automatically.')
    type = models.CharField(max_length=1, choices=PACKAGE_TYPE, default=RECHARGE, verbose_name='Type of Package.')
    local = models.BooleanField(default=True, verbose_name='Local Numbers?')
    is_active = models.BooleanField(default=False)

    cost = models.DecimalField(max_digits=7, decimal_places=2, blank=True, null=True, default=0.0,
                               help_text="Stripe amount.")

    trial_days = models.PositiveIntegerField(blank=True, default=0)
    package_type_after_trial = models.ForeignKey('self', null=True, blank=True, on_delete=models.SET_NULL)

    sms = models.IntegerField(blank=True, null=True, default=0, help_text='SMS')
    mms = models.IntegerField(blank=True, null=True, default=0, help_text='MMS')
    email = models.IntegerField(blank=True, null=True, default=0, help_text='EMAIL')
    talktime = models.IntegerField(blank=True, null=True, default=0, help_text='VOICE')

    is_twilio_number_included = models.BooleanField(default=False)

    note = models.TextField(blank=True, null=True)
    social_media = models.BooleanField(default=True)
    campaigns = models.BooleanField(default=True)
    team = models.BooleanField(default=True)
    rover_min = models.BooleanField(default=True)
    recurring = models.BooleanField(default=False, help_text="Recurring, monthly.")

    # All packages are recurring
    teams = models.IntegerField(blank=True, null=True, default=0)
    digital_att = models.IntegerField(blank=True, null=True, default=0)
    phones = models.IntegerField(blank=True, null=True, default=0,
                                 help_text="Amount of phone numbers included in the Plan")

    scanner = models.BooleanField(default=True)
    scanner_cost = models.IntegerField(blank=True, null=True, default=0)

    creator = models.ForeignKey(settings.ACCOUNT_USER_PROXY_MODEL, blank=True, null=True, on_delete=models.SET_NULL)

    date_created = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    # define the field the model should be ordered by
    ordering = models.PositiveIntegerField(default=0, editable=False, db_index=True)

    # Model Managers
    objects = models.Manager()
    recharge_objects = RechargesPackageManager()
    subscription_objects = SubscriptionsPackageManager()

    class Meta:
        db_table = 'packages_typ'
        ordering = ('ordering',)
        verbose_name = "Package"
        verbose_name_plural = "Packages"

    def __str__(self):
        return str(self.title)

    @property
    def stripe_cost(self):
        """Translate our package cost to the Stripe cost precision."""
        return int((self.cost * 100).to_integral())

    @property
    def plan_cost(self):
        """Returns int value. This property is used in the legacy templates."""
        return int(self.cost)

    def has_different_price(self, plan_for_compare):
        """
        Returns True if the plan received differ in amount price:
        [package.cost] vs [stripe_plan.amount]
        """
        if self.stripe_cost != plan_for_compare.amount:
            return True

        return False

    def push_to_stripe(self):
        """
        Private method: sync push/create (if doesnt exists) Package in Stripe
        """
        if self.is_active:
            try:
                stripe_plan = self.get_stripe_plan()
            except InvalidRequestError as e:
                stripe_plan = None
                logger.error("Error pushing package to Stripe".format(str(e)))

            if stripe_plan and self.has_different_price(stripe_plan):
                stripe_plan.delete()
                stripe_plan = None

            if not stripe_plan:
                self.create_stripe_plan()
            else:
                self.update_stripe_plan_info(stripe_plan)

    def get_stripe_plan(self):
        """Returns stripe plan. based in self.sku"""
        return stripe.Plan.retrieve(self.sku)

    def delete_in_stripe(self):
        """
        Delete package from the Stripe account.
        Deleting plans means new subscribers can’t be added. Existing subscribers aren’t affected.
        """
        try:
            stripe_plan = self.get_stripe_plan()
            stripe_plan.delete()

        except InvalidRequestError as e:
            logger.error("Error deleting Package {} in Stripe Account. {}".format(self.sku, str(e)))

    def create_stripe_plan(self):
        """Private method: create a new Stripe plan based in our package Information"""
        try:
            new_plan = {
                'id': self.sku,
                'amount': self.stripe_cost,
                'interval': self.DEFAULT_BILLING_FREQUENCY,
                'nickname': self.title,
                'product': {
                    'name': self.title,
                    'type': 'service'
                },
                'currency': self.DEFAULT_CURRENCY
            }
            stripe.Plan.create(**new_plan)
        except Exception as err:
            logger.fatal("Fatal error creating Stripe package. {0}".format(err))
            raise Exception("Error creating Stripe package. {0}".format(err))

    def update_stripe_plan_info(self, stripe_plan):
        """Update Stripe Plan information"""
        stripe_plan.nickname = self.title
        stripe_plan.save()


class TwilioNumber(models.Model):
    """
    Twilio Number model representation.
    Here all Purchased Twilio numbers are stored.
    """
    user = models.ForeignKey(settings.ACCOUNT_USER_PROXY_MODEL, on_delete=models.CASCADE)
    twilio_number = models.CharField(max_length=15, unique=True)
    twilio_number_sid = models.CharField(max_length=35, blank=True, null=True)
    friendly_name = models.CharField(max_length=50, blank=True, null=True)
    area_code = models.IntegerField(blank=True, null=True)
    country_code = models.CharField(max_length=3, blank=True, null=True)

    sms_enabled = models.BooleanField(default=False)
    mms_enabled = models.BooleanField(default=False)
    voice_enabled = models.BooleanField(default=True)

    voice_url = models.CharField(max_length=255, blank=True, null=True)
    sms_url = models.CharField(max_length=255, blank=True, null=True)
    in_use = models.BooleanField(default=False, verbose_name='Campaign Use')
    date_created = models.DateTimeField(auto_now_add=True)
    is_redirected = models.BooleanField(
        default=False, verbose_name='Redirected')
    last_updated = models.DateTimeField(auto_now=True)

    def __str__(self):
        return "Phone:{}".format(self.friendly_name)

    class Meta:
        db_table = 'twilio_nos'
        verbose_name = "Purchased Twilio number"
        verbose_name_plural = "Purchased Twilio numbers"

    @property
    def current_domain(self):
        return Site.objects.get_current().domain

    @property
    def absolute_voice_url(self):
        """Returns absolute voice URL."""
        return "https://{}{}".format(self.current_domain, self.voice_url)

    @property
    def absolute_sms_url(self):
        """Returns absolute SMS URL"""
        return "https://{}{}".format(self.current_domain, self.sms_url)

    @staticmethod
    def twilio_api():
        """Returns an instance of the Twilio Rest Client. API."""
        return TwilioRestClient(settings.TWILIO_SID, settings.TWILIO_TOKEN)

    def task_update_twilio_urls(self):
        """Wrapper. Called Google Cloud Task: task_update_twilio_urls."""
        return cloud_tasks.task_update_twilio_urls(tw_id=self.id).execute()

    def task_release_twilio_number(self):
        """Wrapper. Called Google Cloud Task: task_release_twilio_number."""
        return cloud_tasks.task_release_twilio_number(tw_id=self.id).execute()

    @classmethod
    def bulk_purchase_numbers(cls, user_owner, phone_numbers=[]):
        """
        Wrapper. Purchases the phone numbers at twilio and returns the successfully
        created (and purchased) TwilioNumber instances.
        It returns only the successful ones.
        This does not do anything with charging our clients.
        """
        successfully_purchased_numbers = []

        for n in phone_numbers:
            # Create new twilio phone number.
            try:
                new_tw_number = cls.purchase_twilio_number(user_owner=user_owner, phone_number=n)
                successfully_purchased_numbers.append(new_tw_number)
            except Exception as e:
                logger.error(
                    "Error Purchasing twilio numbers for user {} Error: {}".format(user_owner.email, str(e))
                )

        return successfully_purchased_numbers

    @classmethod
    def purchase_twilio_number(cls, user_owner, phone_number):
        """
        Wrapper method of twilio.incoming_phone_numbers.create(phone_number).
        This allows to purchase twilio numbers. Returns a TwilioNumber Instance.
        """
        api = cls.twilio_api()
        tw_number = api.incoming_phone_numbers.create(phone_number=phone_number)

        new_twilio_number, created = cls.objects.get_or_create(
            twilio_number=tw_number.phone_number,
            defaults={"user": user_owner}
        )

        # Mapping object.
        new_twilio_number.twilio_number_sid = tw_number.sid
        new_twilio_number.sms_enabled = tw_number.capabilities['sms']
        new_twilio_number.mms_enabled = tw_number.capabilities['mms']
        new_twilio_number.voice_enabled = tw_number.capabilities['voice']
        new_twilio_number.friendly_name = tw_number.friendly_name

        # Save changes.
        new_twilio_number.save()

        # Set url handlers to default.
        new_twilio_number.update_twilio_urls_to_default()

        return new_twilio_number

    def get_campaign(self):
        # TODO: Imrpove this function
        from ccc.campaigns.models import Campaign
        campaign = Campaign.objects.filter(phone=self.id)
        if campaign:
            return campaign[0]
        else:
            return None

    def idle(self):
        """
        This set False in_use bool for twilio phone number and update to the default voice and sms handlers,
        so number will be avalaible for use in other campaigns or surveys of the owner number.
        """
        self.in_use = False
        self.update_twilio_urls_to_default()

    def release_twilio_number(self):
        """Release/delete this number from the twilio account."""
        try:  # TODO #Techdebt protected from deletion when number is in use.
            api = self.twilio_api()
            tw_obj = api.incoming_phone_numbers.get(self.twilio_number_sid).fetch()
            tw_obj.delete()
            logger.info("The number (%s) was successfully released." % self.twilio_number_sid)
        except TwilioRestException as exception:
            logger.error(str(exception))
            raise exception

    def update_twilio_urls_to_default(self):
        """Set the default twilio webhook handlers for voice and sms"""
        self.voice_url = reverse(settings.TWILIO_DEFAULT_VOICE_HANDLER_URL_NAME)
        self.sms_url = reverse(settings.TWILIO_DEFAULT_SMS_HANDLER_URL_NAME)
        self.save()

        # call update twilio urls async task
        self.task_update_twilio_urls()

    def update_twilio_urls(self):
        """Update the twilio webhooks handlers with the current local data"""
        try:
            api = self.twilio_api()
            tw_number = api.incoming_phone_numbers.get(self.twilio_number_sid).fetch()
            tw_number.update(voice_url=self.absolute_voice_url, sms_url=self.absolute_sms_url)
        except TwilioRestException as exception:
            logger.error(str(exception))
            raise exception


class PurchasedPackage(models.Model):
    user = models.ForeignKey(settings.ACCOUNT_USER_PROXY_MODEL, on_delete=models.CASCADE)
    type = models.ForeignKey(PackageType, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    paid = models.BooleanField(default=True)
    approved = models.BooleanField(default=True)
    recur = models.BooleanField(default=False)
    period = models.CharField(max_length=255, blank=True, null=True)

    def __str__(self):
        return "User email:{} | Package #: {}".format(self.user.email, self.id)

    class Meta:
        db_table = 'ppackage'
        verbose_name = "Purchased Package"
        verbose_name_plural = "Purchased Packages"


class Usage(models.Model):
    """
    Usage Model.
    """
    SMS = '1'
    MMS = '2'
    VOICE = '3'
    EMAIL = '4'
    CCC_FXN = (('1', 'SMS'), ('2', 'MMS'), ('3', 'Voice'), ('4', 'Email'))

    user = models.ForeignKey(settings.ACCOUNT_USER_PROXY_MODEL, on_delete=models.CASCADE)
    type = models.CharField(max_length=1, choices=CCC_FXN)
    amount = models.IntegerField(blank=True, null=True, default=0)

    def __str__(self):
        return "{} # {}".format(self.user.email, self.type)


class Credit(models.Model):
    package = models.ForeignKey(PurchasedPackage, blank=True, null=True, on_delete=models.SET_NULL)
    sms = models.IntegerField(blank=True, null=True, default=0)
    mms = models.IntegerField(blank=True, null=True, default=0)
    talktime = models.IntegerField(blank=True, null=True, default=0)
    email = models.IntegerField(blank=True, null=True, default=0)
    phones = models.IntegerField(blank=True, null=True, default=0)
    date_created = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    def __str__(self):
        return "Package: {}".format(self.package)

    @classmethod
    def add(cls, kwargs):
        return cls.objects.create(**kwargs)


def package_purchase_email(username, sms, mms, phones, emails, talktime, email, cost, created_time):
    from cloud_tools.contrib.mail.send import send_templated_email
    from django.contrib.sites.models import Site
    current_site = Site.objects.get_current()

    HOSTNAME = current_site.domain
    # url = "http://" + HOSTNAME + "/user/confirm/" + activation_code+'/'
    host = "https://" + HOSTNAME + "/static/"

    try:
        if created_time:
            year = created_time.date().strftime("%Y")
            month = created_time.date().strftime("%B")

        # email_body_tmpl = Template(mtn.sms_reply_email_body)
        # email_body = email_body_tmpl.substitute(name=sender_name)
        send_templated_email(
            subject="Purchased Package on Cloud Custom Connections",
            email_template_name='templated_email/invoice.html',
            sender='hello@cloudcustomconnections.com',
            recipients=email,
            email_context={
                'sms': sms,
                'username': username,
                'host': host,
                'mms': mms,
                'emails': emails,
                'phones': phones,
                'cost': cost,
                'month': month,
                'year': year,
                'talktime': talktime

            }
        )
    except Exception as e:
        pass


def send_package_purchase_email(sender, instance, created, **kwargs):
    if created:

        if instance.package:
            user = settings.ACCOUNT_USER_PROXY_MODEL.objects.get(id=instance.package.user.id)

        package_purchase_email(
            user.email, instance.sms, instance.mms, instance.phones,
            instance.email, instance.talktime, user.email, instance.package.type.plan_cost,
            instance.date_created
        )


post_save.connect(signal_push_package_to_stripe, sender=PackageType)
post_delete.connect(signal_delete_package_in_stripe, sender=PackageType)
post_delete.connect(signal_delete_twilio_number, sender=TwilioNumber)
# post_save.connect(send_package_purchase_email, sender=Credit)
