from collections import OrderedDict
from datetime import datetime, timedelta
from typing import Any, Callable, Dict, Iterator, List, Optional, Set, Tuple, Type, Union

from django.db.models import QuerySet
from django.db.models.fields import Field
from django.db.models.lookups import Lookup
from django.db.models.sql import Query
from django.db.models.sql.compiler import SQLCompiler

class SQLiteNumericMixin:
    def as_sqlite(self, compiler: SQLCompiler, connection: Any, **extra_context: Any) -> Tuple[str, List[float]]: ...

class Combinable:
    ADD: str = ...
    SUB: str = ...
    MUL: str = ...
    DIV: str = ...
    POW: str = ...
    MOD: str = ...
    BITAND: str = ...
    BITOR: str = ...
    BITLEFTSHIFT: str = ...
    BITRIGHTSHIFT: str = ...
    def __neg__(self) -> CombinedExpression: ...
    def __add__(self, other: Optional[Union[timedelta, Combinable, float, str]]) -> CombinedExpression: ...
    def __sub__(self, other: Union[timedelta, Combinable, float]) -> CombinedExpression: ...
    def __mul__(self, other: Union[timedelta, Combinable, float]) -> CombinedExpression: ...
    def __truediv__(self, other: float) -> CombinedExpression: ...
    def __mod__(self, other: int) -> CombinedExpression: ...
    def __pow__(self, other: float) -> CombinedExpression: ...
    def __and__(self, other: Combinable) -> Any: ...
    def bitand(self, other: int) -> CombinedExpression: ...
    def bitleftshift(self, other: int) -> CombinedExpression: ...
    def bitrightshift(self, other: int) -> CombinedExpression: ...
    def __or__(self, other: Combinable) -> Any: ...
    def bitor(self, other: int) -> CombinedExpression: ...
    def __radd__(self, other: Optional[Union[datetime, float]]) -> CombinedExpression: ...
    def __rsub__(self, other: float) -> CombinedExpression: ...
    def __rmul__(self, other: float) -> CombinedExpression: ...
    def __rtruediv__(self, other: float) -> CombinedExpression: ...
    def __rmod__(self, other: int) -> CombinedExpression: ...
    def __rpow__(self, other: float) -> CombinedExpression: ...
    def __rand__(self, other: Any) -> Any: ...
    def __ror__(self, other: Any) -> Any: ...

class BaseExpression:
    is_summary: bool = ...
    filterable: bool = ...
    window_compatible: bool = ...
    def __init__(self, output_field: Optional[Union[Field, str]] = ...) -> None: ...
    def get_db_converters(self, connection: Any) -> List[Callable]: ...
    def get_source_expressions(self) -> List[Any]: ...
    def set_source_expressions(self, exprs: List[Any]) -> None: ...
    def as_sql(self, compiler: Any, connection: Any) -> None: ...
    def contains_aggregate(self) -> bool: ...
    def contains_over_clause(self) -> bool: ...
    def contains_column_references(self) -> bool: ...
    def resolve_expression(
        self,
        query: Any = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> BaseExpression: ...
    @property
    def field(self) -> Field: ...
    @property
    def output_field(self) -> Field: ...
    def convert_value(self) -> Callable: ...
    def get_lookup(self, lookup: str) -> Optional[Type[Lookup]]: ...
    def get_transform(self, name: str) -> Optional[Type[Expression]]: ...
    def relabeled_clone(self, change_map: Union[Dict[Optional[str], str], OrderedDict]) -> Expression: ...
    def copy(self) -> BaseExpression: ...
    def get_group_by_cols(self) -> List[Expression]: ...
    def get_source_fields(self) -> List[Optional[Field]]: ...
    def asc(self, **kwargs: Any) -> Expression: ...
    def desc(self, **kwargs: Any) -> Expression: ...
    def reverse_ordering(self): ...
    def flatten(self) -> Iterator[Expression]: ...
    def __hash__(self) -> int: ...

class Expression(BaseExpression, Combinable): ...

class CombinedExpression(SQLiteNumericMixin, Expression):
    connector: Any = ...
    lhs: Any = ...
    rhs: Any = ...
    def __init__(self, lhs: Combinable, connector: str, rhs: Combinable, output_field: None = ...) -> None: ...
    def get_source_expressions(self) -> Union[List[Combinable], List[SQLiteNumericMixin]]: ...
    def set_source_expressions(self, exprs: List[Combinable]) -> None: ...
    def as_sql(self, compiler: SQLCompiler, connection: Any) -> Any: ...
    def resolve_expression(
        self,
        query: Any = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> CombinedExpression: ...

class F(Combinable):
    name: str
    def __init__(self, name: str): ...
    def resolve_expression(
        self,
        query: Any = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[str]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Expression: ...

class OuterRef(F): ...

class Subquery(Expression):
    template: str = ...
    queryset: QuerySet = ...
    extra: Dict[Any, Any] = ...
    def __init__(self, queryset: QuerySet, output_field: Optional[Field] = ..., **extra: Any) -> None: ...

class Exists(Subquery):
    extra: Dict[Any, Any]
    template: str = ...
    negated: bool = ...
    def __init__(self, *args: Any, negated: bool = ..., **kwargs: Any) -> None: ...
    def __invert__(self) -> Exists: ...

class OrderBy(BaseExpression):
    template: str = ...
    nulls_first: bool = ...
    nulls_last: bool = ...
    descending: bool = ...
    expression: Expression = ...
    def __init__(
        self, expression: Combinable, descending: bool = ..., nulls_first: bool = ..., nulls_last: bool = ...
    ) -> None: ...

class Value(Expression):
    value: Any = ...
    def __init__(self, value: Any, output_field: Optional[Field] = ...) -> None: ...

class RawSQL(Expression):
    output_field: Field
    params: List[Any]
    sql: str
    def __init__(self, sql: str, params: Union[List[int], List[str], Tuple], output_field: None = ...) -> None: ...

class Func(SQLiteNumericMixin, Expression):
    function: Any = ...
    template: str = ...
    arg_joiner: str = ...
    arity: Any = ...
    source_expressions: List[Expression] = ...
    extra: Any = ...
    def __init__(self, *expressions: Any, output_field: Optional[Any] = ..., **extra: Any) -> None: ...
    def get_source_expressions(self) -> List[Combinable]: ...
    def set_source_expressions(self, exprs: List[Expression]) -> None: ...
    def resolve_expression(
        self,
        query: Query = ...,
        allow_joins: bool = ...,
        reuse: Optional[Set[Any]] = ...,
        summarize: bool = ...,
        for_save: bool = ...,
    ) -> Func: ...
    def copy(self) -> Func: ...

class When(Expression):
    template: str = ...
    condition: Any = ...
    result: Any = ...
    def __init__(self, condition: Any = ..., then: Any = ..., **lookups: Any) -> None: ...

class Case(Expression):
    template: str = ...
    case_joiner: str = ...
    cases: Any = ...
    default: Any = ...
    extra: Any = ...
    def __init__(
        self, *cases: Any, default: Optional[Any] = ..., output_field: Optional[Any] = ..., **extra: Any
    ) -> None: ...
