---
CANDigitalInput:
  methods:
    CANDigitalInput:  # constructor
      code: |
        self._device = device
        self._limitSwitch = limitSwitch
        polarity_param = (
            "limitSwitchFwdPolarity"
            if limitSwitch is LimitSwitch.kForward
            else "limitSwitchRevPolarity"
        )
        device._hal_data[polarity_param] = polarity
    Get:
      code: |
        retval = self._device.getFault(
            FaultID.kHardLimitFwd
            if self._limitSwitch is LimitSwitch.kForward
            else FaultID.kHardLimitRev
        )
    EnableLimitSwitch:
      code: |
        param = (
            "hardLimitFwdEn"
            if self._limitSwitch is LimitSwitch.kForward
            else "hardLimitRevEn"
        )
        self._device._hal_data[param] = enable
    IsLimitSwitchEnabled:
      code: |
        param = (
            "hardLimitFwdEn"
            if self._limitSwitch is LimitSwitch.kForward
            else "hardLimitRevEn"
        )
        retval = self._device._hal_data[param]

CANEncoder:
  methods:
    CANEncoder:  # constructor
      code: |
        self._device = device
        self._hal_data = device._hal_data
    GetPosition:
      get: position
    GetVelocity:
      get: velocity

CANPIDController:
  methods:
    CANPIDController:  # constructor
      code: |
        self._device = device
        self._hal_data = device._hal_data
    SetReference:
      code: |
        self._hal_data["value"] = float(value)  # TODO
        self._hal_data["ctrlType"] = ctrl
        self._hal_data["pid_slot"] = pidSlot
        self._hal_data["arb_ff"] = arbFeedforward
    SetP:
      hook: pid_set
    SetI:
      hook: pid_set
    SetD:
      hook: pid_set
    SetFF:
      hook: pid_set
    SetIZone:
      hook: pid_set
    SetOutputRange:
      code: |
        self._hal_data["outputMin_%d" % slotID] = float(min)
        self._hal_data["outputMax_%d" % slotID] = float(max)
    GetP:
      hook: pid_get
    GetI:
      hook: pid_get
    GetD:
      hook: pid_get
    GetFF:
      hook: pid_get
    GetIZone:
      hook: pid_get
    GetOutputMin:
      hook: pid_get
    GetOutputMax:
      hook: pid_get

CANSparkMaxLowLevel:
  methods:
    CANSparkMaxLowLevel:  # constructor
      param_override:
        type:
          x_type: rev::CANSparkMaxLowLevel::MotorType
    GetFirmwareVersion:
      ignore: true  # overload + out param
    SetParameter:
      overload: true
    GetParameter:
      ignore: true  # overload + out param

CANSparkMax:
  # __bases__: CANSparkMaxLowLevel
  # cpp_inherits: rev::CANSparkMaxLowLevel

  methods:
    CANSparkMax:  # constructor
      param_override:
        type:
          x_type: rev::CANSparkMaxLowLevel::MotorType
      code: |
        # super().__init__(deviceID, type)
        self._faults = NotifyDict({})  # type: typing.Dict[FaultID, bool]
        # camel case for stored parameters (see CANSparkMaxLowLevel::ConfigParameter)
        self._hal_data = NotifyDict({
            "motorType": type,
            "can_timeout": 20,
            "value": 0.0,
            "inverted": False,
            "position": 0.0,
            "velocity": 0.0,
            "ctrlType": ControlType.kDutyCycle,
            "pid_slot": 0,
            "arb_ff": 0.0,
            "faults": self._faults,
            "limitSwitchFwdPolarity": LimitSwitchPolarity.kNormallyOpen,
            "limitSwitchRevPolarity": LimitSwitchPolarity.kNormallyOpen,
            "hardLimitFwdEn": False,
            "hardLimitRevEn": False,
            "currentChop": 60.0,  # TODO
            "currentChopCycles": 0,
            "idleMode": IdleMode.kCoast,
            "rampRate": 0.0,
            "bus_voltage": 12.0,
            "output_current": 0.1,
            "motor_temp": 25.0,  # ~room temperature
        })
        for i in range(4):
            self._hal_data.update({
                "p_%d" % i: 0.0,
                "i_%d" % i: 0.0,
                "d_%d" % i: 0.0,
                "f_%d" % i: 0.0,
                "iZone_%d" % i: 0.0,
                "outputMin_%d" % i: 0.0,
                "outputMax_%d" % i: 0.0,
            })
        hal_data["CAN"]["sparkmax-%d" % deviceID] = self._hal_data
        hal.report(hal.UsageReporting.kResourceType_RevSparkMaxCAN, deviceID)
        self.clearFaults()

    Set:
      code: |
        self._hal_data["value"] = float(speed)
        self._hal_data["ctrlType"] = ControlType.kDutyCycle
        self._hal_data["pid_slot"] = 0
        self._hal_data["arb_ff"] = 0.0
    Get:
      get: value  # close enough
    SetInverted:
      set: inverted
    GetInverted:
      get: inverted
    Disable:
      code: |
        self.set(0)
    StopMotor:
      code: |
        self.disable()
    PIDWrite:
      rename: pidWrite
      code: |
        self.set(output)
    GetEncoder:
      code: |
        retval = CANEncoder(self)
    GetPIDController:
      code: |
        retval = CANPIDController(self)
    GetForwardLimitSwitch:
      code: |
        retval = CANDigitalInput(self, LimitSwitch.kForward, polarity)
    GetReverseLimitSwitch:
      code: |
        retval = CANDigitalInput(self, LimitSwitch.kReverse, polarity)
    SetSmartCurrentLimit:
      overload: true
    SetSecondaryCurrentLimit:
      code: |
        self._hal_data["currentChop"] = float(limit)
        self._hal_data["currentChopCycles"] = limitCycles
      doc: |
        Sets the secondary current limit in Amps.

        The motor controller will disable the output of the controller briefly
        if the current limit is exceeded to reduce the current. This limit is
        a simplified 'on/off' controller. This limit is enabled by default
        but is set higher than the default Smart Current Limit.

        The time the controller is off after the current limit is reached
        is determined by the parameter limitCycles, which is the number of
        PWM cycles (20kHz). The recommended value is the default of 0 which
        is the minimum time and is part of a PWM cycle from when the over
        current is detected. This allows the controller to regulate the current
        close to the limit value.

        The total time is set by the equation::

          t = (50us - t0) + 50us * limitCycles
          t = total off time after over current
          t0 = time from the start of the PWM cycle until over current is detected

        :param limit: The current limit in Amps.
        :param limitCycles: The number of additional PWM cycles to turn
                            the driver off after overcurrent is detected.
    SetIdleMode:
      set: idleMode
    GetIdleMode:
      get: idleMode
    SetRampRate:
      set: rampRate
    GetRampRate:
      get: rampRate
    Follow:
      ignore: true  # overload + struct
    # TODO IsFollower
    GetFaults:
      code: |
        retval = 0
        for faultID, value in self._faults.items():
            retval |= value << faultID.value
    GetStickyFaults:
      code: |
        retval = 0
    GetFault:
      code: |
        retval = self._faults.get(faultID, False)
    GetStickyFault:
      code: |
        retval = False
    GetBusVoltage:
      get: bus_voltage
    GetAppliedOutput:
      get: value
    GetOutputCurrent:
      get: output_current
    GetMotorTemperature:
      get: motor_temp
    ClearFaults:
      code: |
        faults = self._hal_data["faults"]
        faults.clear()
        faults.update({
            FaultID.kHardLimitFwd: False,
            FaultID.kHardLimitRev: False,
        })
    BurnFlash:
      code: ""
    SetCANTimeout:
      set: can_timeout
