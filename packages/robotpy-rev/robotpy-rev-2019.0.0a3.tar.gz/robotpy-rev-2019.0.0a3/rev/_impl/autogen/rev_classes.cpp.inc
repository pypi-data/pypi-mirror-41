/**
    This file is autogenerated
*/

  py::class_<rev::CANDigitalInput> candigitalinput(m, "CANDigitalInput");
  candigitalinput
      .def("get", &rev::CANDigitalInput::Get, release_gil())
      .def("enableLimitSwitch", &rev::CANDigitalInput::EnableLimitSwitch, py::arg("enable"), release_gil())
      .def("isLimitSwitchEnabled", &rev::CANDigitalInput::IsLimitSwitchEnabled, release_gil())
  ;
  py::class_<rev::CANEncoder> canencoder(m, "CANEncoder");
  canencoder
      .def("getPosition", &rev::CANEncoder::GetPosition, release_gil())
      .def("getVelocity", &rev::CANEncoder::GetVelocity, release_gil())
  ;
  py::class_<rev::CANPIDController> canpidcontroller(m, "CANPIDController");
  canpidcontroller
      .def("setReference", &rev::CANPIDController::SetReference, py::arg("value"), py::arg("ctrl"), py::arg("pidSlot")=0, py::arg("arbFeedforward")=0, release_gil())
      .def("setP", &rev::CANPIDController::SetP, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setI", &rev::CANPIDController::SetI, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setD", &rev::CANPIDController::SetD, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setFF", &rev::CANPIDController::SetFF, py::arg("gain"), py::arg("slotID")=0, release_gil())
      .def("setIZone", &rev::CANPIDController::SetIZone, py::arg("IZone"), py::arg("slotID")=0, release_gil())
      .def("setOutputRange", &rev::CANPIDController::SetOutputRange, py::arg("min"), py::arg("max"), py::arg("slotID")=0, release_gil())
      .def("getP", &rev::CANPIDController::GetP, py::arg("slotID")=0, release_gil())
      .def("getI", &rev::CANPIDController::GetI, py::arg("slotID")=0, release_gil())
      .def("getD", &rev::CANPIDController::GetD, py::arg("slotID")=0, release_gil())
      .def("getFF", &rev::CANPIDController::GetFF, py::arg("slotID")=0, release_gil())
      .def("getIZone", &rev::CANPIDController::GetIZone, py::arg("slotID")=0, release_gil())
      .def("getOutputMin", &rev::CANPIDController::GetOutputMin, py::arg("slotID")=0, release_gil())
      .def("getOutputMax", &rev::CANPIDController::GetOutputMax, py::arg("slotID")=0, release_gil())
  ;
  py::class_<rev::CANSparkMax> cansparkmax(m, "CANSparkMax");
  cansparkmax
      .def(py::init<int, rev::CANSparkMaxLowLevel::MotorType>(), py::arg("deviceID"), py::arg("type"), release_gil())
      .def("set", &rev::CANSparkMax::Set, py::arg("speed"), release_gil())
      .def("get", &rev::CANSparkMax::Get, release_gil())
      .def("setInverted", &rev::CANSparkMax::SetInverted, py::arg("isInverted"), release_gil())
      .def("getInverted", &rev::CANSparkMax::GetInverted, release_gil())
      .def("disable", &rev::CANSparkMax::Disable, release_gil())
      .def("stopMotor", &rev::CANSparkMax::StopMotor, release_gil())
      .def("pidWrite", &rev::CANSparkMax::PIDWrite, py::arg("output"), release_gil())
      .def("getEncoder", &rev::CANSparkMax::GetEncoder, release_gil())
      .def("getPIDController", &rev::CANSparkMax::GetPIDController, release_gil())
      .def("getForwardLimitSwitch", &rev::CANSparkMax::GetForwardLimitSwitch, py::arg("polarity"), release_gil())
      .def("getReverseLimitSwitch", &rev::CANSparkMax::GetReverseLimitSwitch, py::arg("polarity"), release_gil())
      .def("setSmartCurrentLimit", (rev::CANError (rev::CANSparkMax::*)(unsigned int))&rev::CANSparkMax::SetSmartCurrentLimit, py::arg("limit"), release_gil())
      .def("setSmartCurrentLimit", (rev::CANError (rev::CANSparkMax::*)(unsigned int, unsigned int, unsigned int))&rev::CANSparkMax::SetSmartCurrentLimit, py::arg("stallLimit"), py::arg("freeLimit"), py::arg("limitRPM")=20000, release_gil())
      .def("setSecondaryCurrentLimit", &rev::CANSparkMax::SetSecondaryCurrentLimit, py::arg("limit"), py::arg("limitCycles")=0, release_gil())
      .def("setIdleMode", &rev::CANSparkMax::SetIdleMode, py::arg("mode"), release_gil())
      .def("getIdleMode", &rev::CANSparkMax::GetIdleMode, release_gil())
      .def("setRampRate", &rev::CANSparkMax::SetRampRate, py::arg("rate"), release_gil())
      .def("getRampRate", &rev::CANSparkMax::GetRampRate, release_gil())
      .def("isFollower", &rev::CANSparkMax::IsFollower, release_gil())
      .def("getFaults", &rev::CANSparkMax::GetFaults, release_gil())
      .def("getStickyFaults", &rev::CANSparkMax::GetStickyFaults, release_gil())
      .def("getFault", &rev::CANSparkMax::GetFault, py::arg("faultID"), release_gil())
      .def("getStickyFault", &rev::CANSparkMax::GetStickyFault, py::arg("faultID"), release_gil())
      .def("getBusVoltage", &rev::CANSparkMax::GetBusVoltage, release_gil())
      .def("getAppliedOutput", &rev::CANSparkMax::GetAppliedOutput, release_gil())
      .def("getOutputCurrent", &rev::CANSparkMax::GetOutputCurrent, release_gil())
      .def("getMotorTemperature", &rev::CANSparkMax::GetMotorTemperature, release_gil())
      .def("clearFaults", &rev::CANSparkMax::ClearFaults, release_gil())
      .def("burnFlash", &rev::CANSparkMax::BurnFlash, release_gil())
      .def("setCANTimeout", &rev::CANSparkMax::SetCANTimeout, py::arg("milliseconds"), release_gil())
  ;
  candigitalinput
      .def(py::init<rev::CANSparkMax&, rev::CANDigitalInput::LimitSwitch, rev::CANDigitalInput::LimitSwitchPolarity>(), py::arg("device"), py::arg("limitSwitch"), py::arg("polarity"), release_gil())
  ;
  canencoder
      .def(py::init<rev::CANSparkMax&>(), py::arg("device"), release_gil())
  ;
  canpidcontroller
      .def(py::init<rev::CANSparkMax&>(), py::arg("device"), release_gil())
  ;
